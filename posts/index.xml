<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Jparagdev&#39;s blog</title>
        <link>/posts/</link>
        <description>Recent content in Posts on Jparagdev&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Mon, 01 Feb 2021 21:23:00 +0900</lastBuildDate>
        <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Event-driven이 뭐지</title>
            <link>/posts/programming/event-driven/</link>
            <pubDate>Mon, 01 Feb 2021 21:23:00 +0900</pubDate>
            
            <guid>/posts/programming/event-driven/</guid>
            <description>간간이 기술 블로그나 유튜브를 보다 보면 Event-Driven Programming , Event-Driven Architecture 등등 Event-Driven이라는 단어가 많이 보인다. 대충 어림짐작으로 생각했을 때는 비동기적으로 처리되는 이벤트들을 실시간으로 잘 처리 해주는 것이 이벤트 드리븐이 아닐까? 라는 생각을 했다.
이번 포스팅으로 스스로 정리하는 시간을 가지려 한다. 먼저 wikipedia 를 찾아봤다.
Event-driven architecture
Event-driven architecture (EDA) is a software architecture paradigm promoting the production, detection, consumption of, and reaction to events.
이벤트 드리븐 아키텍쳐란 이벤트를 중심으로 생산,감지,소비,반응을 촉진하는 소프트웨어 패러다임이라 한다.</description>
            <content type="html"><![CDATA[<p>간간이 기술 블로그나 유튜브를 보다 보면 Event-Driven Programming , Event-Driven Architecture 등등 Event-Driven이라는 단어가 많이 보인다.
대충 어림짐작으로 생각했을 때는 비동기적으로 처리되는 이벤트들을 실시간으로 잘 처리 해주는 것이 이벤트 드리븐이 아닐까? 라는 생각을 했다.</p>
<p>이번 포스팅으로 스스로 정리하는 시간을 가지려 한다.
먼저 wikipedia 를 찾아봤다.</p>
<p>Event-driven architecture<br>
Event-driven architecture (EDA) is a software architecture paradigm promoting the production, detection, consumption of, and reaction to events.</p>
<p>이벤트 드리븐 아키텍쳐란 이벤트를 중심으로 생산,감지,소비,반응을 촉진하는 소프트웨어 패러다임이라 한다.</p>
<p>Event-driven programming<br>
In computer programming, event-driven programming is a programming paradigm in which the flow of the program is determined by events such as user actions (mouse clicks, key presses), sensor outputs, or message passing from other programs or threads.</p>
<p>이벤트 드리븐 프로그래밍은 프로그램의 흐름이 사용자의 액션이나, 센서의 정보, 다른 프로그램이나 쓰레드로 부터오는 메세지의 전달로 결정되는 프로그래밍 패러다임이다.</p>
<p>두 단어 모두 이벤트가 중심이 되는 걸 알 수 있다. 그럼 정확히 프로그래밍에서 말하는 이벤트는 무엇일까? 
나는 일상적으로 서프라이즈 이벤트나 프로모션 이벤트가 먼저 연상된다. 여기서 말하는 이벤트와는 사뭇 다른 느낌이긴 하다.
프로그래밍에서 말하는 이벤트는</p>
<ol>
<li>
<p>사용자의 액션, 즉 작게는 마우스의 클릭이나 키보드의 입력부터 주문결wp나 회원가입 등등 사용자가 서비스에 하는 행위</p>
</li>
<li>
<p>프로그램과 프로그램 사이 또는 프로세서 사이에서 일어나는 메세지 교환</p>
</li>
<li>
<p>외부기기로부터 발생하는 데이터를 전달받는 것</p>
</li>
</ol>
<p>이 외에 여러 가지 이벤트가 있겠지만 내가 생각했던 이벤트의 비슷한 건 하나 있다.
&lsquo;순차적으로 일어나지 않고 어느 순간 갑자기 발생한다는 것&rsquo;
아마 통신환경과 컴퓨팅기술의 발전에 따라 다양하고 복잡한 이벤트가 동시에 일어나는 경우가 많아지고 트래픽이 증가하여 이에 대응하는 방법으로 비동기 처리에 유리한 이벤트 드리븐 방식이 주목받지 않았나 싶다.</p>
<p>그럼 이러한 이벤트 드리븐 방식이 어떻게 구현되어 사용되고 있는지 알아보자
먼저 이벤트 드리븐 아키텍쳐의 예로 NodeJs가 대표적이다.</p>
<figure>
    <img src="/images/programming/event-driven.png"
         alt="hugo complete"/> <figcaption>
            <p><a href="https://diophant.com/blog/mitigating-node-js-event-loop-saturation">https://diophant.com/blog/mitigating-node-js-event-loop-saturation</a></p>
        </figcaption>
</figure>

<p>Node Js는 위와 같이 발생하는 이벤트들을 이벤트 루프를 돌며 스레드에 각각 분배하여 이벤트를 처리하는 방식으로 구성되어 있다. (I/O 등 커널을 사용해야하는 이벤트는 제외)<br>
Event-Driven Programming 도 동일하게 하나의 이벤트 리스너를 두고 멀티스레드에 분배하는 방식인 듯하나 나중에 자신이 코딩하게 되거나 좋은 코드를 보게 되면 이 글에 추가하도록 하겠다</p>
<p>이벤트 드리븐 방식은 다양한 트레픽에 비동기 식으로 대응하기에 적합한 패러다임이고 Kafka, Spring Webflux, NodeJs, Nginx 등 다양한 프레임워크에서도 채택하였다.<br>
이런 프레임 워크들은 성능적으로도 주목받고 있다. 나는 아직 실무 프로젝트에서 사용하며 체감해보지 못했지만 먼저 개념적으로 익숙해지고 준비해 나가는게 좋을 것 같다.</p>
<p>참고<br>
<a href="https://news.samsung.com/kr/%EC%9A%94%EC%A6%98-%EC%A0%9C%EC%9D%BC-%ED%95%AB%ED%95%98%EB%8B%A4%EB%8A%94-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%93%9C%EB%A6%AC%EB%B8%90-%EB%88%84%EA%B5%AC%EB%83%90-%EB%84%8C">https://news.samsung.com/kr/요즘-제일-핫하다는-이벤트-드리븐-누구냐-넌</a><br>
<a href="https://en.wikipedia.org/wiki/Event-driven_architecture">https://en.wikipedia.org/wiki/Event-driven_architecture</a><br>
<a href="https://en.wikipedia.org/wiki/Event-driven_programming">https://en.wikipedia.org/wiki/Event-driven_programming</a></p>
]]></content>
        </item>
        
        <item>
            <title>github.io 블로그 만들기 - 2</title>
            <link>/posts/blog/hugo-2/</link>
            <pubDate>Thu, 21 Jan 2021 21:00:00 +0900</pubDate>
            
            <guid>/posts/blog/hugo-2/</guid>
            <description>이전 블로그에 이어 이번엔 테마를 설정해보도록 하겠다.
https://themes.gohugo.io/tags/blog/
위 페이지에 접속하여 원하는 테마를 골라보도록 하자. 일반적으로 모든 테마에서는 설치법과 기본적인 사용법이 개발자분들이 적어 놓은 경우가 많아 이를 참고하는것이 좋긴하다.
일단 내가 적용했던 방법을 기록해본다.
간편하게 생성했던 프로젝트 파일 themes 아래 서브모듈로 추가하거나 (테마제작자의 업데이트가 상관없는경우 가능)
$ git clone &amp;lt;테마 Git주소&amp;gt; themes/&amp;lt;테마이름&amp;gt; $ git submodule add &amp;lt;테마 Git주소&amp;gt; themes/&amp;lt;테마이름&amp;gt; 아니면 직접 다운받아 themes폴더 아래에 위치시켜주면 된다.
이후 config.toml파일을 각 테마에 맞게 수정해줘야한다.</description>
            <content type="html"><![CDATA[<p>이전 블로그에 이어 이번엔 테마를 설정해보도록 하겠다.</p>
<p><a href="https://themes.gohugo.io/tags/blog/">https://themes.gohugo.io/tags/blog/</a></p>
<p>위 페이지에 접속하여 원하는 테마를 골라보도록 하자. 
일반적으로 모든 테마에서는 설치법과 기본적인 사용법이 개발자분들이 적어 놓은 경우가 많아 이를 참고하는것이 좋긴하다.</p>
<p>일단 내가 적용했던 방법을 기록해본다.</p>
<p>간편하게 생성했던 프로젝트 파일 themes 아래 서브모듈로 추가하거나 (테마제작자의 업데이트가 상관없는경우 가능)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ git clone &lt;테마 Git주소&gt; themes/&lt;테마이름&gt;
$ git submodule add &lt;테마 Git주소&gt; themes/&lt;테마이름&gt;
</code></pre></div><p>아니면 직접 다운받아 themes폴더 아래에 위치시켜주면 된다.</p>
<p>이후 config.toml파일을 각 테마에 맞게 수정해줘야한다. 
테마별 사이트에 자세히 나와있어 맞게 수정하면 되며, 기본적으로 baseURL, Theme, Title 정도는 기본으로 설정해야 한다.</p>
<p>이제 시험삼아 Post를 하나 생성해보도록 하자</p>
<p>Hugo는 Content 아래의 폴더가 게시글이 되도록 기본적으로 설정되어 있다. 
나는 주제에 맞춰 혹은 시리즈에 맞춰 폴더를 생성하고 그아래 .md 파일을 하나 생성해서 글을 작성했다.</p>
<p>테마도 적용되었는지 확인하고 글도 잘올라갔는지 확인하려면 먼저 내컴퓨터에서 홈페이지를 기동해봐야한다. 
Intellij같은 툴을 쓰는경우 환경 설정을 통해 쉽게 본인 PC에 서버를 올릴 수 있고 shell을 통해 기동도 가능하다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ hugo server -D
</code></pre></div><figure>
    <img src="/images/hugo/hugo-4.png"
         alt="hugo server"/> <figcaption>
            <p>해당화면처럼 빌드가 되면 가능</p>
        </figcaption>
</figure>

<p>이제 localhost:1313번에 접속해서 자신의 블로그를 확인해보도록 하자</p>
]]></content>
        </item>
        
        <item>
            <title>github.io 블로그 만들기 - 1</title>
            <link>/posts/blog/hugo-1/</link>
            <pubDate>Sun, 17 Jan 2021 20:45:00 +0900</pubDate>
            
            <guid>/posts/blog/hugo-1/</guid>
            <description>기록은 힘이다 말이 있듯이 자신만의 지식 아카이브를 만들어 두는 것은 큰 도움이 된다. 다른사람에게 정보 전달의 목적도 있지만 나 자신의 생각을 정리하기 위해 블로그를 기록하기로 한다.
github는 간편하면서 무료로 호스팅을 한다. 다만, 정적인 페이지로만 생성이 가능
내가 만들 블로그의 경우는 방문자에게 정보 전달만이 목적이기에 Static Website로 구성 현재는 많은 개발자분들이 Github를 통해 블로그를 구축하는듯 하다
먼저 블로그를 구축하기전에 Git에 대한 기본적이 지식이 필요하다. Git에 대한 정보는 이미 웹에 많은 좋은 기록이 많기 때문에 따로 다루진 않는다.</description>
            <content type="html"><![CDATA[<p>기록은 힘이다 말이 있듯이 자신만의 지식 아카이브를 만들어 두는 것은 큰 도움이 된다.
다른사람에게 정보 전달의 목적도 있지만 나 자신의 생각을 정리하기 위해 블로그를 기록하기로 한다.</p>
<p>github는 간편하면서 무료로 호스팅을 한다. 다만, 정적인 페이지로만 생성이 가능</p>
<p>내가 만들 블로그의 경우는 방문자에게 정보 전달만이 목적이기에 Static Website로 구성
현재는 많은 개발자분들이 Github를 통해 블로그를 구축하는듯 하다</p>
<p>먼저 블로그를 구축하기전에 Git에 대한 기본적이 지식이 필요하다.
Git에 대한 정보는 이미 웹에 많은 좋은 기록이 많기 때문에 따로 다루진 않는다.
대신 Opentutorials의 강의를 링크한다.<br>
<a href="https://opentutorials.org/course/2708">https://opentutorials.org/course/2708</a></p>
<p>나는 Hugo를 사용하여 블로그를 구성하기로 했다. 
Github.io에 Jekyll가 대표적이지만,
Jekyll에 비해 빌드속도가 빠르다는 점과 Go 언어를 사용한다는점이 매력적이라 생각해서 Hugo를 선택!</p>
<p>비록 Jekyll에 비해 메뉴얼도 템플릿도 부족한 듯 싶으나 일단 Hugo를 사용하기로 맘먹고 시작해보았다.
Hugo에 마음에 드는 테마가 있던 것도 한 몫했다.</p>
<p>먼저 Hugo는 <a href="https://gohugo.io/getting-started/installing/">https://gohugo.io/getting-started/installing/</a> 에서 OS별 설치 방법을 알 수 있고 
Git (<a href="https://github.com/gohugoio/hugo">https://github.com/gohugoio/hugo</a>) 에서 최신 Hugo를 다운받아 사용이 가능하다. OS는 Window 10에서 진행하였다.</p>
<p>Hugo를 다운받았다면 원하는 위치에서 압축을 풀고 bin폴더 안의 hugo.exe의 환경변수를 설정해주도록 한다.
<figure>
    <img src="/images/hugo/hugo-1.png"
         alt="hugo setting path"/> <figcaption>
            <p>윈도우의 시스템 환경설정</p>
        </figcaption>
</figure>
</p>
<p>이후 cmd를 통해 Hugo가 제대로 작동하는 지 확인한다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">    $ hugo version
</code></pre></div><p>다음과 같은 화면이 나온다면 정상적으로 작동 된 것
<figure>
    <img src="/images/hugo/hugo-2.png"
         alt="hugo install"/> <figcaption>
            <p>Hugo 버전확인</p>
        </figcaption>
</figure>
</p>
<p>이제 블로그용 소스를 만들 위치에 hugo site파일을 만들어보도록 하자</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">    $ hugo new site C:<span style="color:#ae81ff">\j</span>aprangev<span style="color:#ae81ff">\t</span>estsite
</code></pre></div><p>해당 메세지가 출력되고 파일이 잘 생성된 것을 확인하였으면 기본적인 블로그 사이트 소스 생성이 된 것이다.</p>
<figure>
    <img src="/images/hugo/hugo-3.png"
         alt="hugo complete"/> <figcaption>
            <p>간략하게 테마적용법과 구동방법이 나온다</p>
        </figcaption>
</figure>

<p>다음으로 Git을 통해 형상관리가 가능하도록 원격 git을 연결하도록 하자
먼저 <a href="https://github.com">https://github.com</a> 으로 접속하여 저장소를 2개 생성해야한다.</p>
<ol>
<li>블로그 소스용 저장소</li>
<li>블로그가 게시될 Github.io 용 저장소</li>
</ol>
<p>new site로 생성한 블로그 소스를 원격 저장소에 연결해보자.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">    $ cd C:<span style="color:#ae81ff">\j</span>aprangev<span style="color:#ae81ff">\t</span>estsite
    $ git init
    $ git add .
    $ git commit -m <span style="color:#e6db74">&#34;first commit&#34;</span>
    $ git branch -M main
    $ git remote add origin https://github.com/jparangdev/testsite-src.git
    $ git push -u origin main
</code></pre></div><p>github에 접속해 해당 소스가 제대로 푸쉬가 되었는지 확인</p>
<p>여기까지 글을 마치고 다음에 테마를 연결해보자~~~~</p>
]]></content>
        </item>
        
        <item>
            <title>Kafka 알아보기 - 1</title>
            <link>/posts/kafka/about-kafka-1/</link>
            <pubDate>Wed, 16 Dec 2020 21:43:00 +0900</pubDate>
            
            <guid>/posts/kafka/about-kafka-1/</guid>
            <description>1. What is Kafka ?   https://www.confluent.io/blog/kafka-fastest-messaging-system
  Apache Kafka is an evnet streaming platform Kafka는 오픈소스 분산메세지 플랫폼이다. 실시간으로 대량의 스트림(메세지)를 처리하는데 적합한 Messaging Queue(MQ)의 일종 Kafka는 대용량의 메세지 처리가 필요한 링크드인에서 개발해 2011년 아파치의 공식 오픈소스로 공개되었다. 다른 분산 메세징 시스템에 비해 비교적 우수한 성능을 보여주어, 현재 많은 기업에서 사용중이라고 한다.
2. Kafka Process   Kafka의 기본 구조
  Kafka는 기본적으로 Publish/Subscribe 구조를 사용한다. Producer가 메세지를 발행(Publish)하면 Topic을 구독(Subscribe)하는 Consumer가 메세지를 소비하는 구조 거기에 Broker(Kafka)가 둘 사이를 중계하며 메세지를 효율적으로 전달하는 역할을 한다.</description>
            <content type="html"><![CDATA[<h2 id="1-what-is-kafka-">1. What is Kafka ?</h2>
<figure>
    <img src="/images/kafka/about-kafka-fastest.png"
         alt="kafka process - 1"/> <figcaption>
            <p><a href="https://www.confluent.io/blog/kafka-fastest-messaging-system">https://www.confluent.io/blog/kafka-fastest-messaging-system</a></p>
        </figcaption>
</figure>

<h4 id="apache-kafka-is-an-evnet-streaming-platform">Apache Kafka is an evnet streaming platform</h4>
<p>Kafka는 오픈소스 분산메세지 플랫폼이다.
실시간으로 대량의 스트림(메세지)를 처리하는데 적합한 Messaging Queue(MQ)의 일종
Kafka는 대용량의 메세지 처리가 필요한 링크드인에서 개발해 2011년 아파치의 공식 오픈소스로 공개되었다.
다른 분산 메세징 시스템에 비해 비교적 우수한 성능을 보여주어, 현재 많은 기업에서 사용중이라고 한다.</p>
<h2 id="2-kafka-process">2. Kafka Process</h2>
<figure>
    <img src="/images/kafka/about-kafka-process.png"
         alt="kafka process - 1"/> <figcaption>
            <p>Kafka의 기본 구조</p>
        </figcaption>
</figure>

<p>Kafka는 기본적으로 Publish/Subscribe 구조를 사용한다.
Producer가 메세지를 발행(Publish)하면 Topic을 구독(Subscribe)하는 Consumer가 메세지를 소비하는 구조
거기에 Broker(Kafka)가 둘 사이를 중계하며 메세지를 효율적으로 전달하는 역할을 한다.
이렇게 각각 독립적으로 기능을 수행하며 서로 연결되어 있는 구성을 느슨한 결합(Loosely Coupled)이라 한다.</p>
<p>다수의 Producer가 데이터를 메세지화 하여 전송하면 Kafka가 <a href="/posts/programming/event-driven/">Event-Driven</a> 방식으로 대량의 메세지를 병렬적으로 처리하며 해당 Topic을 구독하고있는 Consumer에게 전송하게 된다.</p>
<h2 id="3-kafka-component">3. Kafka Component</h2>
<figure>
    <img src="/images/kafka/about-kafka-component.png"
         alt="kafka Component - 1"/> <figcaption>
            <p><em>Kafka의 구성요소</em></p>
        </figcaption>
</figure>

<p>Kafak의 기본적인 구성요소들을 하나씩 살펴보면</p>
<ul>
<li>
<p><strong>Topic</strong>
메세지의 종류 또는 카테고리이다. Producer가 특정 Topic으로 메세지를 생성하면, 이 Topic을 구독하고 있는 Consumer는 메세지를 소비한다.</p>
</li>
<li>
<p><strong>Partition</strong><br>
Topic 내에서 메세지가 분산되어 저장되는 Queue. 하나의 Topic에 단일 Partition인 경우 순서가 보장 될 수 있으나, 다중 Partition인 경우 각 Partition의 끝에서 Round-Robin 방식으로 쓰여지기 때문에 읽어 올 때 그 순서를 보장 할 수 없다.  Topic내 Partition 수는 설정이 가능하며은 한번 늘리면 다시 줄일 수 없음.</p>
</li>
<li>
<p><strong>Log</strong><br>
Partition의 한 메세지 부분</p>
</li>
<li>
<p><strong>Broker</strong><br>
Kafka의 서버를 의미한다. Broker 여러개가 Cluster를 구성하며, Zookeeper를 통해 메타데이터를 공유</p>
</li>
<li>
<p><strong>Zookeeper</strong><br>
Kafka의 메타정보를 관리하는 프로그램 Zookeeper가 실행되어야 Kafka가 실행 될 수 있다.</p>
</li>
</ul>
]]></content>
        </item>
        
    </channel>
</rss>
