<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Jparangdev&#39;s blog</title>
        <link>/posts/</link>
        <description>Recent content in Posts on Jparangdev&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Sun, 14 Feb 2021 14:06:00 +0900</lastBuildDate>
        <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>2021년엔 M.S.A로</title>
            <link>/posts/programming/msa/</link>
            <pubDate>Sun, 14 Feb 2021 14:06:00 +0900</pubDate>
            
            <guid>/posts/programming/msa/</guid>
            <description>MSA ( Micro Service Architecture ) 이미 많은 유명한 기업에선 MSA를 많이 채택하고 있다.
거기에 따라 MSA에 대하여 자세하고 이해하기 쉽게 정리해둔 포스팅도 많으나 이번에도 역시 스스로의 생각을 정리하고 기록하자는 의미에서 포스팅을 남겨본다.잘못된 내용이나 주관적인 생각이 들어갈 수 있음을 미리 양해를 구한다.
일단 정말 잘 정리해둔 몇개의 포스팅을 링크해본다. 이미 구글 상위권 검색을 차지하고 있지만..
참조
https://velog.io/@tedigom/MSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1-MSA%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-3sk28yrv0e
https://www.samsungsds.com/kr/insights/msa.html
The term &amp;ldquo;Microservice Architecture&amp;rdquo; has sprung up over the last few years to describe a particular way of designing software applications as suites of independently deployable services.</description>
            <content type="html"><![CDATA[<h2 id="msa--micro-service-architecture-">MSA ( Micro Service Architecture )</h2>
<p>이미 많은 유명한 기업에선 MSA를 많이 채택하고 있다.<br>
거기에 따라 MSA에 대하여 자세하고 이해하기 쉽게 정리해둔 포스팅도 많으나 이번에도 
역시 스스로의 생각을 정리하고 기록하자는 의미에서 포스팅을 남겨본다.잘못된 내용이나 주관적인 생각이 들어갈 수 있음을 미리 양해를 구한다.</p>
<p>일단 정말 잘 정리해둔 몇개의 포스팅을 링크해본다. 이미 구글 상위권 검색을 차지하고 있지만..</p>
<p>참조</p>
<p><a href="https://velog.io/@tedigom/MSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1-MSA%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-3sk28yrv0e">https://velog.io/@tedigom/MSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1-MSA%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-3sk28yrv0e</a></p>
<p><a href="https://www.samsungsds.com/kr/insights/msa.html">https://www.samsungsds.com/kr/insights/msa.html</a></p>
<p>The term &ldquo;Microservice Architecture&rdquo; has sprung up over the last few years to describe a particular way of designing software applications as suites of independently deployable services. While there is no precise definition of this architectural style, there are certain common characteristics around organization around business capability, automated deployment, intelligence in the endpoints, and decentralized control of languages and data.</p>
<p>이분의 말을 꽤 많이 인용한다.</p>
<p>독립적으로 배포가능한 서비스들로 구성된 소프트웨어 설계방식을 말하는 것이며 해당 설계스타일에 확실한 정의는 없지만 비즈니스 수행에 관련된 조직, 배포 자동화, 앤드포인트의 지능, 그리고 언어와 데이터의 탈중앙화가 공통된 특징이라 한다..</p>
<p>가장 중요한건 탈중앙화, 즉 하나의 서비스가 어플리케이션 전체의 중심이 되는 것이 아니라 다양한 서비스이 자신만의 기능를 중시하며 다른 서비스들과 상호작용을 통해 어플리케이션을 구성한다는 말인듯 하다.
MSA를 이용한 대표적인 기업인 Netflex가 있다. 넷플릭스는 7년에 걸쳐 MSA를 도입했다고 한다. 과연 MSA는 무슨매력이 있을까?</p>
<p>MSA를 이야기 할 때 흔히 Monolithic 아키텍쳐와 비교하여 이야기를 많이한다. 모놀리식은 어플리케이션 전체를 하나의 서비스로 구성하는 방법이다.
예를 들어 쇼핑몰의 경우 기본적으로 상품을 조회하는 서비스, 주문을 등록하는 서비스, 결제 서비스, 관리자 서비스 등등 이 하나의 서비스에 단일 데이터베이스로 연결되어 있는 방식이 모놀리식의 예가 된다.</p>
<figure>
    <img src="https://drive.google.com/uc?export=view&amp;id=1tZWd1gHLY9RYVvAKoK-YgifoIH05TWpo"
         alt="Monolithic"/> <figcaption>
            <p>하나의 서비스로 엮긴 어플리케이션</p>
        </figcaption>
</figure>

<p>반대로 마이크로서비스는 각각의 서비스들이 분리되어 있으며 고객의 요청에 따라 해당서비스만 호출하는 방식으로 구성되어 있고 데이터베이스 또한 분리되어 작동하는 방식을 예로 들 수 있다</p>
<figure>
    <img src="https://drive.google.com/uc?export=view&amp;id=1zFFNRp-wpTjz_Z4sOmicKjPkz1SO83JL"
         alt="Monolithic"/> <figcaption>
            <p>서로를 호출하는 방식</p>
        </figcaption>
</figure>

<p>그림이 도움이 될 지 모르겠다. 다만 이런느낌임을 알아두자 :)
이러한 구조적 차이 때문에 장단점이 확실하다.</p>
<h3 id="모놀리식">모놀리식</h3>
<pre><code> + 개발 초기엔 구조가 단순하고 직관적이여 상대적으로 개발하기 쉽다.
 + 하나의 서버환경이서 빌드 및 배포가 번거롭지 않고 쉽다. 
 + 테스트 및 모니터링이 용이하다.

 - 하나의 문제가 전제적인 서비스에 영향을 줄 수 있다.
 - 서비스 규모가 커짐에 따라  복잡성이 늘어나게 되어 개발이 어려워지고 1번 단점이 다발적으로 일어 날 수 있다. 
 - 초반 기술스택을 변경하기 어려워진다.
</code></pre>
<h3 id="마이크로서비스">마이크로서비스</h3>
<pre><code> + 하나의 서비스에 문제가 발생시 다른 서비스까지의 영향도가 적다
 + 각 모듈간의 스케일 아웃이 용이하다.
 + 다양한 언어 또는 기술 스택으로 구성 할 수 있다.

 - 서비스가 여러개여서 모니터링이 어렵다.
 - 개발간에 다른 모듈과의 통신이 필수적이기 때문에 초기 설계 및 개발난이도가 높다. 
 - 전체적인 테스트를 구성하기 어렵다.
</code></pre>
<p>내가 경험한 모놀리식의 장단점을 생각해보면, 일단 데이터베이스에 문제가 발생시 어플리케이션 전체가 중단된다거나 서버의 메모리 또는 디스크용량문제로 서버가 멈춘다는 문제가 있었다. 
또한 다중화 되지않은 서버구성이라면 빌드 후 배포시 서버 재기동이 필요한 경우도 있다. 물론 서버의 스케일업이나, 이중화 서버를 구성하는 문제로 해결 할 수도 있다.
마이크로서비스는 경험해보진 못했지만 각 서비스간의 스케일 아웃이 가능하고 문제발생시 문제되는 서비스에만 집중 할 수 있는면이 장점으로 보인다. 추후 마이크로서비스를 경험하게 되면,
장단점을 다시 정리해보도록 하자.</p>
<p>시간이 지나갈 수록 외부에서 어플리케이션에게 요구하는 데이터양과 복잡성은 커져간다. 이에 유연하게 대응하기위해 MSA는 좋은 선택일 것 같다. 
넷플릭스뿐만아니라 우리나라의 각 IT기업들도 MSA를 도입해가고 있다. 
이러한 과정안에서도 많은 시간과 노력이 필요하겠지만 그럼에도 선두기업들이 MSA를 도입하는 이유가 있을 것이다. 
조금 더 많은 글을 읽어보고 생각을 넓혀가야겠다.</p>
]]></content>
        </item>
        
        <item>
            <title>Event-driven이 뭐지?</title>
            <link>/posts/programming/event-driven/</link>
            <pubDate>Mon, 01 Feb 2021 21:23:00 +0900</pubDate>
            
            <guid>/posts/programming/event-driven/</guid>
            <description>간간이 기술 블로그나 유튜브를 보다 보면 Event-Driven Programming , Event-Driven Architecture 등등 Event-Driven이라는 단어가 많이 보인다. 대충 어림짐작으로 생각했을 때는 비동기적으로 처리되는 이벤트들을 실시간으로 잘 처리 해주는 것이 이벤트 드리븐이 아닐까? 라는 생각을 했다.
이번 포스팅으로 스스로 정리하는 시간을 가지려 한다. 먼저 wikipedia 를 찾아봤다.
Event-driven architecture
Event-driven architecture (EDA) is a software architecture paradigm promoting the production, detection, consumption of, and reaction to events.
이벤트 드리븐 아키텍쳐란 이벤트를 중심으로 생산,감지,소비,반응을 촉진하는 소프트웨어 패러다임이라 한다.</description>
            <content type="html"><![CDATA[<p>간간이 기술 블로그나 유튜브를 보다 보면 Event-Driven Programming , Event-Driven Architecture 등등 Event-Driven이라는 단어가 많이 보인다.
대충 어림짐작으로 생각했을 때는 비동기적으로 처리되는 이벤트들을 실시간으로 잘 처리 해주는 것이 이벤트 드리븐이 아닐까? 라는 생각을 했다.</p>
<p>이번 포스팅으로 스스로 정리하는 시간을 가지려 한다.
먼저 wikipedia 를 찾아봤다.</p>
<p>Event-driven architecture<br>
Event-driven architecture (EDA) is a software architecture paradigm promoting the production, detection, consumption of, and reaction to events.</p>
<p>이벤트 드리븐 아키텍쳐란 이벤트를 중심으로 생산,감지,소비,반응을 촉진하는 소프트웨어 패러다임이라 한다.</p>
<p>Event-driven programming<br>
In computer programming, event-driven programming is a programming paradigm in which the flow of the program is determined by events such as user actions (mouse clicks, key presses), sensor outputs, or message passing from other programs or threads.</p>
<p>이벤트 드리븐 프로그래밍은 프로그램의 흐름이 사용자의 액션이나, 센서의 정보, 다른 프로그램이나 쓰레드로 부터오는 메세지의 전달로 결정되는 프로그래밍 패러다임이다.</p>
<p>두 단어 모두 이벤트가 중심이 되는 걸 알 수 있다. 그럼 정확히 프로그래밍에서 말하는 이벤트는 무엇일까? 
나는 일상적으로 서프라이즈 이벤트나 프로모션 이벤트가 먼저 연상된다. 여기서 말하는 이벤트와는 사뭇 다른 느낌이긴 하다.
프로그래밍에서 말하는 이벤트는</p>
<ol>
<li>
<p>사용자의 액션, 즉 작게는 마우스의 클릭이나 키보드의 입력부터 주문결제나 회원가입 등등 사용자가 서비스에 하는 행위</p>
</li>
<li>
<p>프로그램과 프로그램 사이 또는 프로세서 사이에서 일어나는 메세지 교환</p>
</li>
<li>
<p>외부기기로부터 발생하는 데이터를 전달받는 것</p>
</li>
</ol>
<p>이 외에 여러 가지 이벤트가 있겠지만 내가 생각했던 이벤트의 비슷한 건 하나 있다.
&lsquo;순차적으로 일어나지 않고 어느 순간 갑자기 발생한다는 것&rsquo;
아마 통신환경과 컴퓨팅기술의 발전에 따라 다양하고 복잡한 이벤트가 동시에 일어나는 경우가 많아지고 트래픽이 증가하여 이에 대응하는 방법으로 비동기 처리에 유리한 이벤트 드리븐 방식이 주목받지 않았나 싶다.</p>
<p>그럼 이러한 이벤트 드리븐 방식이 어떻게 구현되어 사용되고 있는지 알아보자
먼저 이벤트 드리븐 아키텍쳐의 예로 NodeJs가 대표적이다.</p>
<figure>
    <img src="/images/programming/event-driven.png"
         alt="hugo complete"/> <figcaption>
            <p><a href="https://diophant.com/blog/mitigating-node-js-event-loop-saturation">https://diophant.com/blog/mitigating-node-js-event-loop-saturation</a></p>
        </figcaption>
</figure>

<p>Node Js는 위와 같이 발생하는 이벤트들을 이벤트 루프를 돌며 스레드에 각각 분배하여 이벤트를 처리하는 방식으로 구성되어 있다. (I/O 등 커널을 사용해야하는 이벤트는 제외)<br>
Event-Driven Programming 도 동일하게 하나의 이벤트 리스너를 두고 멀티스레드에 분배하는 방식인 듯하나 나중에 자신이 코딩하게 되거나 좋은 코드를 보게 되면 이 글에 추가하도록 하겠다</p>
<p>이벤트 드리븐 방식은 다양한 트레픽에 비동기 식으로 대응하기에 적합한 패러다임이고 Kafka, Spring Webflux, NodeJs, Nginx 등 다양한 프레임워크에서도 채택하였다.<br>
이런 프레임 워크들은 성능적으로도 주목받고 있다. 나는 아직 실무 프로젝트에서 사용하며 체감해보지 못했지만 먼저 개념적으로 익숙해지고 준비해 나가는게 좋을 것 같다.</p>
<p>참고<br>
<a href="https://news.samsung.com/kr/%EC%9A%94%EC%A6%98-%EC%A0%9C%EC%9D%BC-%ED%95%AB%ED%95%98%EB%8B%A4%EB%8A%94-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%93%9C%EB%A6%AC%EB%B8%90-%EB%88%84%EA%B5%AC%EB%83%90-%EB%84%8C">https://news.samsung.com/kr/요즘-제일-핫하다는-이벤트-드리븐-누구냐-넌</a><br>
<a href="https://en.wikipedia.org/wiki/Event-driven_architecture">https://en.wikipedia.org/wiki/Event-driven_architecture</a><br>
<a href="https://en.wikipedia.org/wiki/Event-driven_programming">https://en.wikipedia.org/wiki/Event-driven_programming</a></p>
]]></content>
        </item>
        
        <item>
            <title>Kafka 알아보기 - 2</title>
            <link>/posts/kafka/about-kafka-2/</link>
            <pubDate>Sat, 23 Jan 2021 14:22:00 +0900</pubDate>
            
            <guid>/posts/kafka/about-kafka-2/</guid>
            <description>그럼 이제 실제로 카프카를 한번 설치해보자
Kafka Download URL : https://kafka.apache.org/downloads
$ mkdir kafka $ cd kafka $ wget https://downloads.apache.org/kafka/2.6.0/kafka_2.12-2.6.0.tgz $ tar -zxvf kafka_2.12-2.6.0.tgz Kafka를 다운로드 받고 압축을 해제.
압축을 해제한 폴더의 Config폴더로 들어가면 zookeeper.properties 파일이 있다.
Kafka의 메타데이터 관리는 zookeeper가 관리하기 때문에 해당 파일을 통해 설정을 변경 할 수 있다.
$ cd kafka_2.12-2.6.0 $ mkdir data $ echo 1 &amp;gt; myid $ vi myid 미리 zookeeper의 데이터(각 ID)가 저장될 폴더를 생성하자</description>
            <content type="html"><![CDATA[<p>그럼 이제 실제로 카프카를 한번 설치해보자</p>
<p>Kafka Download URL : <a href="https://kafka.apache.org/downloads">https://kafka.apache.org/downloads</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ mkdir kafka
$ cd kafka
$ wget https://downloads.apache.org/kafka/2.6.0/kafka_2.12-2.6.0.tgz
$ tar -zxvf kafka_2.12-2.6.0.tgz
</code></pre></div><p>Kafka를 다운로드 받고 압축을 해제.<br>
압축을 해제한 폴더의 Config폴더로 들어가면 zookeeper.properties 파일이 있다.<br>
Kafka의 메타데이터 관리는 zookeeper가 관리하기 때문에 해당 파일을 통해 설정을 변경 할 수 있다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ cd kafka_2.12-2.6.0
$ mkdir data
$ echo <span style="color:#ae81ff">1</span> &gt; myid
$ vi myid
</code></pre></div><p>미리 zookeeper의 데이터(각 ID)가 저장될 폴더를 생성하자<br>
/app/kafka/kafka-2.6.0-src/data 에 생성</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># Licensed to the Apache Software Foundation (ASF) under one or more</span>
<span style="color:#75715e"># contributor license agreements.  See the NOTICE file distributed with</span>
<span style="color:#75715e"># this work for additional information regarding copyright ownership.</span>
<span style="color:#75715e"># The ASF licenses this file to You under the Apache License, Version 2.0</span>
<span style="color:#75715e"># (the &#34;License&#34;); you may not use this file except in compliance with</span>
<span style="color:#75715e"># the License.  You may obtain a copy of the License at</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e">#    http://www.apache.org/licenses/LICENSE-2.0</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e"># Unless required by applicable law or agreed to in writing, software</span>
<span style="color:#75715e"># distributed under the License is distributed on an &#34;AS IS&#34; BASIS,</span>
<span style="color:#75715e"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span style="color:#75715e"># See the License for the specific language governing permissions and</span>
<span style="color:#75715e"># limitations under the License.</span>
<span style="color:#75715e"># the directory where the snapshot is stored.</span>
<span style="color:#75715e"># 각 서버별 아이디가 저장될 위치를 지정해줍니다.</span>
dataDir<span style="color:#f92672">=</span>/app/kafka/kafka_2.12-2.6.0/data 
<span style="color:#75715e"># the port at which the clients will connect</span>
clientPort<span style="color:#f92672">=</span><span style="color:#ae81ff">2181</span>
<span style="color:#75715e"># disable the per-ip limit on the number of connections since this is a non-production config</span>
maxClientCnxns<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
<span style="color:#75715e"># Disable the adminserver by default to avoid port conflicts.</span>
<span style="color:#75715e"># Set the port to something non-conflicting if choosing to enable this</span>
admin.enableServer<span style="color:#f92672">=</span>false
<span style="color:#75715e"># admin.serverPort=808</span>

<span style="color:#75715e"># 팔로워 파티션과 리더 파티션이 초기 연결되는 시간제한 설정 </span>
initLimit<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span> 

<span style="color:#75715e"># 팔로워 파티션과 리더 파티션이 동기화 되는 시간의 타임아웃</span>
<span style="color:#75715e"># 해당시간내에 동기화 되지 않으면 해제된다.</span>
syncLimmit<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>

<span style="color:#75715e"># 각각의 Kafka Broker 서버정보</span>
juvis-kafka.1<span style="color:#f92672">=(</span>첫번째서버 IP<span style="color:#f92672">)</span>:2888:3888
juvis-kafka.2<span style="color:#f92672">=(</span>두번째서버 IP<span style="color:#f92672">)</span>:2888:3888
</code></pre></div><p>dataDir에 생성한 폴더 주소를 입력하고 initLimit,syncLimmit를 입력한 뒤 각 서버 정보를 입력<br>
자세한 내용은 <a href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a> 페이지를 참고하자.</p>
<p>각각의 서버에서 아까 만들었던 Data폴더 위치에 myid 파일을 만들고 여기에는 각각 아이디의 번호인 1, 2를 입력하자<br>
myid 파일에 쓰인 번호는 <a href="http://zookeeper.properties">zookeeper.properties</a> 파일에 쓰인 .1 .2의 아이디와 연결되는 역할을 한다</p>
<p>이번엔 server.properties 파일을 설정해보자.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">listeners<span style="color:#f92672">=</span>PLAINTEXT://:9092

advertised.listeners<span style="color:#f92672">=</span>PLAINTEXT://192.168.137.101:9092

zookeeper.connect<span style="color:#f92672">=(</span>첫번째 서버 IP<span style="color:#f92672">)</span>:2181, <span style="color:#f92672">(</span>두번째 서버 IP<span style="color:#f92672">)</span>:2181, 
</code></pre></div><p>방화벽도 해재한다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e">## 주키퍼 포트 </span>
firewall-cmd --permanent --zone<span style="color:#f92672">=</span>public --add-port<span style="color:#f92672">=</span>2181/tcp
firewall-cmd --permanent --zone<span style="color:#f92672">=</span>public --add-port<span style="color:#f92672">=</span>2888/tcp
firewall-cmd --permanent --zone<span style="color:#f92672">=</span>public --add-port<span style="color:#f92672">=</span>3888/tcp

<span style="color:#75715e">## 카프카 포트</span>
firewall-cmd --permanent --zone<span style="color:#f92672">=</span>public --add-port<span style="color:#f92672">=</span>9092/tcp
</code></pre></div><p>앞서 진행한 작업들은 각 서버마다 연동을 해주기 위한 기본적인 작업이다.
이제 Zookeeper를 먼저 구동후 Kafka를 구동해보자</p>
<p>기동하려는데 에러 발생.. 원인은 소스파일이아니라 바이너리 파일을 받았어야함..ㅠ
다시 수정해서 위에 진행사항과 동일하게 진행했다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">Classpath is empty. Please build the project first e.g. by running <span style="color:#e6db74">&#39;./gradlew jar -PscalaVersion=2.13.2&#39;</span>
</code></pre></div><p>이런 오류가 뜬다&hellip;</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ bin/zookeeper-server-start.sh config/zookeeper.properties
$ bin/kafka-server-start.sh config/server.properties
</code></pre></div><p>zookeeper를 먼저 기동하고 kafka를 기동해야 한다.</p>
]]></content>
        </item>
        
        <item>
            <title>Kafka 알아보기 - 1</title>
            <link>/posts/kafka/about-kafka-1/</link>
            <pubDate>Fri, 15 Jan 2021 21:43:00 +0900</pubDate>
            
            <guid>/posts/kafka/about-kafka-1/</guid>
            <description>1. What is Kafka ?   https://www.confluent.io/blog/kafka-fastest-messaging-system
  Apache Kafka is an evnet streaming platform Kafka는 오픈소스 분산메세지 플랫폼이다. 실시간으로 대량의 스트림(메세지)를 처리하는데 적합한 Messaging Queue(MQ)의 일종 Kafka는 대용량의 메세지 처리가 필요한 링크드인에서 개발해 2011년 아파치의 공식 오픈소스로 공개되었다. 다른 분산 메세징 시스템에 비해 비교적 우수한 성능을 보여주어, 현재 많은 기업에서 사용중이라고 한다.
2. Kafka Process   Kafka의 기본 구조
  Kafka는 기본적으로 Publish/Subscribe 구조를 사용한다. Producer가 메세지를 발행(Publish)하면 Topic을 구독(Subscribe)하는 Consumer가 메세지를 소비하는 구조 거기에 Broker(Kafka)가 둘 사이를 중계하며 메세지를 효율적으로 전달하는 역할을 한다.</description>
            <content type="html"><![CDATA[<h2 id="1-what-is-kafka-">1. What is Kafka ?</h2>
<figure>
    <img src="/images/kafka/about-kafka-fastest.png"
         alt="kafka process - 1"/> <figcaption>
            <p><a href="https://www.confluent.io/blog/kafka-fastest-messaging-system">https://www.confluent.io/blog/kafka-fastest-messaging-system</a></p>
        </figcaption>
</figure>

<h4 id="apache-kafka-is-an-evnet-streaming-platform">Apache Kafka is an evnet streaming platform</h4>
<p>Kafka는 오픈소스 분산메세지 플랫폼이다.
실시간으로 대량의 스트림(메세지)를 처리하는데 적합한 Messaging Queue(MQ)의 일종
Kafka는 대용량의 메세지 처리가 필요한 링크드인에서 개발해 2011년 아파치의 공식 오픈소스로 공개되었다.
다른 분산 메세징 시스템에 비해 비교적 우수한 성능을 보여주어, 현재 많은 기업에서 사용중이라고 한다.</p>
<h2 id="2-kafka-process">2. Kafka Process</h2>
<figure>
    <img src="/images/kafka/about-kafka-process.png"
         alt="kafka process - 1"/> <figcaption>
            <p>Kafka의 기본 구조</p>
        </figcaption>
</figure>

<p>Kafka는 기본적으로 Publish/Subscribe 구조를 사용한다.
Producer가 메세지를 발행(Publish)하면 Topic을 구독(Subscribe)하는 Consumer가 메세지를 소비하는 구조
거기에 Broker(Kafka)가 둘 사이를 중계하며 메세지를 효율적으로 전달하는 역할을 한다.
이렇게 각각 독립적으로 기능을 수행하며 서로 연결되어 있는 구성을 느슨한 결합(Loosely Coupled)이라 한다.</p>
<p>다수의 Producer가 데이터를 메세지화 하여 전송하면 Kafka가 <a href="/posts/programming/event-driven/">Event-Driven</a> 방식으로 대량의 메세지를 병렬적으로 처리하며 해당 Topic을 구독하고있는 Consumer에게 전송하게 된다.</p>
<h2 id="3-kafka-component">3. Kafka Component</h2>
<figure>
    <img src="/images/kafka/about-kafka-component.png"
         alt="kafka Component - 1"/> <figcaption>
            <p><em>Kafka의 구성요소</em></p>
        </figcaption>
</figure>

<p>Kafak의 기본적인 구성요소들을 하나씩 살펴보면</p>
<ul>
<li>
<p><strong>Topic</strong>
메세지의 종류 또는 카테고리이다. Producer가 특정 Topic으로 메세지를 생성하면, 이 Topic을 구독하고 있는 Consumer는 메세지를 소비한다.</p>
</li>
<li>
<p><strong>Partition</strong><br>
Topic 내에서 메세지가 분산되어 저장되는 Queue. 하나의 Topic에 단일 Partition인 경우 순서가 보장 될 수 있으나, 다중 Partition인 경우 각 Partition의 끝에서 Round-Robin 방식으로 쓰여지기 때문에 읽어 올 때 그 순서를 보장 할 수 없다.  Topic내 Partition 수는 설정이 가능하며은 한번 늘리면 다시 줄일 수 없음.</p>
</li>
<li>
<p><strong>Log</strong><br>
Partition의 한 메세지 부분</p>
</li>
<li>
<p><strong>Broker</strong><br>
Kafka의 서버를 의미한다. Broker 여러개가 Cluster를 구성하며, Zookeeper를 통해 메타데이터를 공유</p>
</li>
<li>
<p><strong>Zookeeper</strong><br>
Kafka의 메타정보를 관리하는 프로그램 Zookeeper가 실행되어야 Kafka가 실행 될 수 있다.</p>
</li>
</ul>
<h2 id="4-topic--partition">4. Topic &amp; Partition</h2>
<figure>
    <img src="/images/kafka/about-kafka-partition.png"
         alt="kafka partiton"/> <figcaption>
            <p><em>이미치 출처 : <a href="https://medium.com/@umanking/%EC%B9%B4%ED%94%84%EC%B9%B4%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%9D%B4%EC%95%BC%EA%B8%B0-%ED%95%98%EA%B8%B0%EC%A0%84%EC%97%90-%EB%A8%BC%EC%A0%80-data%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%9D%B4%EC%95%BC%EA%B8%B0%ED%95%B4%EB%B3%B4%EC%9E%90-d2e3ca2f3c2">https://medium.com/@umanking/%EC%B9%B4%ED%94%84%EC%B9%B4%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%9D%B4%EC%95%BC%EA%B8%B0-%ED%95%98%EA%B8%B0%EC%A0%84%EC%97%90-%EB%A8%BC%EC%A0%80-data%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%9D%B4%EC%95%BC%EA%B8%B0%ED%95%B4%EB%B3%B4%EC%9E%90-d2e3ca2f3c2</a></em></p>
        </figcaption>
</figure>

<p>Producer와 Consumer는 하나의 Topic으로 메세지를 주고 받게 된다.
Topic은 하나 이상의 Partition으로 이루어지게 되는데 이는 많은 메세지를 처리하기 위해 비동기적으로 작동한다.
다수의 Producer는 각각의 Partition에 순차적으로 데이터를 쌓게 되며 Consumer (ConsumerGroup)은 각각의 partition의 offset에 따라 데이터를 구독한다.</p>
<figure>
    <img src="/images/kafka/about-kafka-partition-2.png"
         alt="kafka partiton-2"/> <figcaption>
            <p><em>이미치 출처 : <a href="https://engkimbs.tistory.com/691">https://engkimbs.tistory.com/691</a></em></p>
        </figcaption>
</figure>

<h2 id="5-consumergroup">5. ConsumerGroup</h2>
<p>Consumer Group은 Consumer서버의 모임이라 할 수 있다.
각 ConsumerGroup은 하나의 Topic만 구독한다.
Topic은 여러개의 Consumer Group과 연결되며 Consumer Group은 Consumer 끼리 Topic의 최종 offset을 공유하는 그룹이다.
하나의 Consumer가 이상이 생겼을 경우 나머지 Consumer가 동일하게 메세지를 소비한다.</p>
<p>Consumer Group의 각 Consumer의 숫자에 따라 Partition에 접근하는 방법도 다르다.
Consumer Group안의 Consumer수와 Partition 수가 같은 경우 1:1로 매칭되어 각 Partition의 데이터를 가져오지만 
Consumer가 더 많은 경우 남은 Consumer는 Partition이 늘어날 때까지 대기하게 되며 Partition 숫자가 더 많아지는 경우는 Consumer가 여러개의 partition의 Message를 소비하게 된다.</p>
<figure>
    <img src="/images/kafka/kafak-counsumer-group.png"
         alt="kafka consumer group"/> <figcaption>
            <p><em>이미치 출처 : <a href="https://www.popit.kr/kafka-consumer-group">https://www.popit.kr/kafka-consumer-group</a></em></p>
        </figcaption>
</figure>

<p>하나의 서버가 장애가 생긴경우 ConsumerGroup 에 포함된 다른서버에서는 메세지를 동일 하게 소모 할 수 있다.</p>
<figure>
    <img src="/images/kafka/kafak-counsumer-group-2.png"
         alt="kafka consumer group - 2"/> 
</figure>

<p>참고<br>
<a href="https://kafka.apache.org/intro">https://kafka.apache.org/intro</a><br>
<a href="https://victorydntmd.tistory.com/344">https://victorydntmd.tistory.com/344</a><br>
<a href="https://taetaetae.github.io/2017/11/02/what-is-kafka/">https://taetaetae.github.io/2017/11/02/what-is-kafka/</a><br>
<a href="https://epicdevs.com/17">https://epicdevs.com/17</a><br>
<a href="https://engkimbs.tistory.com/691">https://engkimbs.tistory.com/691</a></p>
]]></content>
        </item>
        
        <item>
            <title>콩(Bean) 이야기</title>
            <link>/posts/spring/bean/</link>
            <pubDate>Sat, 02 Jan 2021 21:23:00 +0900</pubDate>
            
            <guid>/posts/spring/bean/</guid>
            <description>Spring의 콩(bean)에 대해 알아보자
  물론 이 콩이 아니다.
  그럼.. Bean이 뭔데? 간단히 말하면 스프링프레임워크에서 사용하는 자바의 객체를 Bean이라 할 수 있다. 다만 Spring IoC Container(컨테이너)에서 관리되기 때문에 자바객체와 다르게 Bean(빈)이라 말한다. Xml이나 어노테이션을 이용해 메타데이터를 설정하면 컨테이너는 이를 확인해서 빈을 생성하고 해당 빈의 라이프 사이클을 관리하며 필요한 부분에 주입하여 의존성을 관리한다.
  이 콩도 아니다 이 콩도 아니다
  그럼 왜 굳이 Bean을 사용하는가?</description>
            <content type="html"><![CDATA[<p>Spring의 콩(bean)에 대해 알아보자</p>
<figure>
    <img src="https://drive.google.com/uc?export=view&amp;id=10PKsiqX5O0rXqSFMLokk-W5TkX3r_Lke"
         alt="spring"/> <figcaption>
            <p>물론 이 콩이 아니다.</p>
        </figcaption>
</figure>

<h2 id="그럼-bean이-뭔데">그럼.. Bean이 뭔데?</h2>
<p>간단히 말하면 스프링프레임워크에서 사용하는 자바의 객체를 Bean이라 할 수 있다. 다만 Spring IoC Container(컨테이너)에서 관리되기 때문에
자바객체와 다르게 Bean(빈)이라 말한다. Xml이나 어노테이션을 이용해 메타데이터를 설정하면 컨테이너는 이를 확인해서 빈을 생성하고 해당 빈의
라이프 사이클을 관리하며 필요한 부분에 주입하여 의존성을 관리한다.</p>
<figure>
    <img src="https://drive.google.com/uc?export=view&amp;id=1A9aOfWAN-6M0nBpsBJQThfWMylVVckTX"
         alt="spring"/> <figcaption>
            <p>이 콩도 아니다 이 콩도 아니다</p>
        </figcaption>
</figure>

<p>그럼 왜 굳이 Bean을 사용하는가?<br>
스프링에서 개발자는 의존성 주입과 객채의 생성과 소멸은 컨테이너가 해줄테니 개발에 집중할 수 해주는 것이 목적이다.</p>
<figure>
    <img src="https://drive.google.com/uc?export=view&amp;id=1QxKmTIKypqEqZWO7tiy1Y0gq764by_3z"
         alt="spring"/> 
</figure>

<p>그럼 빈을 생성하는 예시를 보며 실제로 빈이 스프링상에서 어떻게 작용하는지 알아보자 (Spring Boot)<br>
빈을 만드는 방법은 여러가지가 있지만 대표적으로 쓰이는 방법을 예시들어 본다.</p>
<h2 id="빈-생성방법">빈 생성방법</h2>
<p>소스상에서 자바 오브젝트를 생성한 뒤 각 방법으로 등록을 할 수 있다.</p>
<ol>
<li>
<p><strong>XML로 지정</strong><br>
application.xml에 빈을 등록하거나 resource 폴더아래 XML파일을 생성 후 지정한다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#75715e">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span style="color:#f92672">&lt;beans</span> <span style="color:#a6e22e">xmlns=</span><span style="color:#e6db74">&#34;http://www.springframework.org/schema/beans&#34;</span>
       <span style="color:#a6e22e">xmlns:xsi=</span><span style="color:#e6db74">&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
       <span style="color:#a6e22e">xsi:schemaLocation=</span><span style="color:#e6db74">&#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&#34;</span><span style="color:#f92672">&gt;</span>
   
    <span style="color:#f92672">&lt;bean</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;xmlBeanTest&#34;</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;co.kr.jparangdev.spring_test1.model.XmlBeanTest&#34;</span> <span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;/beans&gt;</span>
</code></pre></div><p>여러 XML을 만든 경우 설정에서 BeanFactory에서 직접 Context를 불러와 Bean을 넣어주거나, application.xml파일에 Import해서 사용하는 방법이 있다.
빈을 일일히 다 표기해야하며 Context관리가 어려워 불편한 점이 조금 있어보인다.</p>
</li>
<li>
<p><strong>Component-Scan + Annotation</strong><br>
application.xml 에서 Annotation으로 마킹된 객체를 빈으로 주입하는 방법이 있다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;context:component-scan</span> <span style="color:#a6e22e">base-package=</span><span style="color:#e6db74">&#34;co.kr.jparangdev.spring_test1&#34;</span><span style="color:#f92672">/&gt;</span>
</code></pre></div><p>이후 base-package 아래 지정된 객체중 @Component, @Service, @Controller, @Repository으로 마킹한 객체는 빈에 등록된다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> co.kr.jparangdev.spring_test1.controller<span style="color:#f92672">;</span>
   
<span style="color:#f92672">import</span> org.springframework.stereotype.Controller<span style="color:#f92672">;</span>
   
<span style="color:#a6e22e">@Controller</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BeanTestController</span> <span style="color:#f92672">{</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p><strong>@Configuration + @Bean</strong><br>
Spring boot의 경우 @Configuration을 지정한 객체 안에 @Bean으로 생성된 메소드를 생성해서 리턴해주면 빈을 주입 할 수 있다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#f92672">package</span> co.kr.jparangdev.spring_test1.config<span style="color:#f92672">;</span>
       
    <span style="color:#f92672">import</span> co.kr.jparangdev.spring_test1.model.AnnotationBeanTest<span style="color:#f92672">;</span>
    <span style="color:#f92672">import</span> org.springframework.context.annotation.Bean<span style="color:#f92672">;</span>
    <span style="color:#f92672">import</span> org.springframework.context.annotation.Configuration<span style="color:#f92672">;</span>
       
    <span style="color:#a6e22e">@Configuration</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestConfig</span> <span style="color:#f92672">{</span>
        <span style="color:#a6e22e">@Bean</span>
        <span style="color:#66d9ef">public</span> AnnotationBeanTest <span style="color:#a6e22e">annotationBeanTest</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> AnnotationBeanTest<span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div></li>
</ol>
<p>이제 이렇게 주입한 빈들이 제대로 들어갔는지 확인해보자</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@SpringBootApplication</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SpringTest1Application</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        SpringApplication<span style="color:#f92672">.</span><span style="color:#a6e22e">run</span><span style="color:#f92672">(</span>SpringTest1Application<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">,</span> args<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>


    <span style="color:#a6e22e">@Bean</span> <span style="color:#75715e">// Annotation으로 등록한 bean 확인
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> CommandLineRunner <span style="color:#a6e22e">outBeanName</span><span style="color:#f92672">(</span>ApplicationContext ctx<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> args <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;============= Bean Start =============&#34;</span><span style="color:#f92672">);</span>
            String<span style="color:#f92672">[]</span> beanNames <span style="color:#f92672">=</span> ctx<span style="color:#f92672">.</span><span style="color:#a6e22e">getBeanDefinitionNames</span><span style="color:#f92672">();</span>
            Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">stream</span><span style="color:#f92672">(</span>beanNames<span style="color:#f92672">).</span><span style="color:#a6e22e">forEach</span><span style="color:#f92672">(</span>
                    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">::</span>println
            <span style="color:#f92672">);</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;============= Bean End   =============&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">};</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Bean</span> <span style="color:#75715e">// xml로 등록한 bean 확인
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> CommandLineRunner <span style="color:#a6e22e">outXmlBeanName</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> args <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;============= XmlBean Start =============&#34;</span><span style="color:#f92672">);</span>
            ApplicationContext ctx <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ClassPathXmlApplicationContext<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;beans.xml&#34;</span><span style="color:#f92672">);</span>
            String<span style="color:#f92672">[]</span> beanNames <span style="color:#f92672">=</span> ctx<span style="color:#f92672">.</span><span style="color:#a6e22e">getBeanDefinitionNames</span><span style="color:#f92672">();</span>
            Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">stream</span><span style="color:#f92672">(</span>beanNames<span style="color:#f92672">).</span><span style="color:#a6e22e">forEach</span><span style="color:#f92672">(</span>
                    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">::</span>println
            <span style="color:#f92672">);</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;============= XmlBean End   =============&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">};</span>
    <span style="color:#f92672">}</span>

<span style="color:#f92672">}</span>
</code></pre></div><p>결과 화면으로 등록된 Bean의 Name들을 확인 할 수 있다. 
<figure>
    <img src="https://drive.google.com/uc?export=view&amp;id=1Axx6JbPZgFPwBSomfmtIjsQbOclslu0u"
         alt="spring"/> <figcaption>
            <p>Test메소드도 Bean으로 등록되었다.</p>
        </figcaption>
</figure>
</p>
<p>이런 식으로 컨테이너에 등록된 빈들을 여러 방법으로 의존관계를 가지며 상호작용이 가능하다. 
그럼 의존관계는 어떻게 설정 할 수 있을까?</p>
<p>의존관계를 표기하는 방식은 여러가지가 있지만 대표적인 @Autowired 이용한 주입 표기 법이 있다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Service</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AutowiredTestService</span> <span style="color:#f92672">{</span>

    <span style="color:#a6e22e">@Autowired</span>
    AnnotationBeanTest annotationBeanTest<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>다른 주입방법과 빈생성시 DI의 원리에 대해선 좀더 뒤에 알아 보도록 하겠다.<br>
또한 컨테이너에선 빈의 Scope를 관리하기도 한다.</p>
<figure>
    <img src="https://drive.google.com/uc?export=view&amp;id=1lmHcVtsQU4tcNPDwUwxCUg2BVTK8jFGH"
         alt="bean scope"/> 
</figure>

<p>여기서 web spring에서 사용하는 것은 제외하고 singleton과 prototype만 좀더 자세히 알아보자</p>
<p><!-- raw HTML omitted -->Singleton Scope<!-- raw HTML omitted --><br>
스프링 컨테이너는 빈에 관하여 하나의 인스턴스만 관리하며 빈에 대한 요청에 하나의 인스턴스만 반환하게 된다. 컨테이너는 빈을 생성하며 캐시에 저장하여 해당 빈을 참조하는 경우 캐시된 인스턴스를 반환한다.
우리가 알고 있는 Singleton Disign Pattern 과는 조금 다르게 작용한다고 한다. 일반적인 싱글톤 패턴은 하나의 시스템 내부에서 하나의 클래스에 하나의 인스턴스만 존재하지만 빈의 싱글톤은 컨테이너내의 하나의 빈의 정의에 대해 하나의 인스턴스를 가지는 걸 말한다.
<figure>
    <img src="https://drive.google.com/uc?export=view&amp;id=1EiFDxsYs_RNOPlt3AzFuuKn8F_rf5_cf"
         alt="singleton"/> <figcaption>
            <p>출처 : <a href="https://docs.spring.io/spring-framework/docs/5.3.5-SNAPSHOT/reference/html/core.html#beans-factory-scopes-singleton">https://docs.spring.io/spring-framework/docs/5.3.5-SNAPSHOT/reference/html/core.html#beans-factory-scopes-singleton</a></p>
        </figcaption>
</figure>
</p>
<p><!-- raw HTML omitted -->Prototype Scope<!-- raw HTML omitted --> <br>
프로토 타입은 싱글톤 패턴과 반대로 컨테이너는 모든 빈의 요청에 하나하나의 인스턴스를 만들어 준다.  일반적으로 상태값을 사용해야 하는 빈은 프로토타입을 사용하고 상태를 고려 안하는 경우는 싱글톤을 사용한다. 
<figure>
    <img src="https://drive.google.com/uc?export=view&amp;id=1XUUTc_y2eKSc98nI19wa3W-xTxXfmiHN"
         alt="protoType"/> <figcaption>
            <p>출처 : <a href="https://docs.spring.io/spring-framework/docs/5.3.5-SNAPSHOT/reference/html/core.html#beans-factory-scopes-singleton">https://docs.spring.io/spring-framework/docs/5.3.5-SNAPSHOT/reference/html/core.html#beans-factory-scopes-singleton</a></p>
        </figcaption>
</figure>
</p>
<p>빈의 Scope를 지정하는 방법은 빈의 생성방법과 맞물려 있다.</p>
<ol>
<li>xml에 Scope속성을 추가해준다.</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;bean</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;xmlBeanTest&#34;</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;co.kr.jparangdev.spring_test1.model.XmlBeanTest&#34;</span> <span style="color:#a6e22e">scope=</span><span style="color:#e6db74">&#34;singleton&#34;</span><span style="color:#f92672">/&gt;</span>
</code></pre></div><ol start="2">
<li>@Scope를 이용한다.</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Configuration</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestConfig</span> <span style="color:#f92672">{</span>
    <span style="color:#a6e22e">@Bean</span>
    <span style="color:#a6e22e">@Scope</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;protoType&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#66d9ef">public</span> AnnotationBeanTest <span style="color:#a6e22e">annotationBeanTest</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> AnnotationBeanTest<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>그럼 실제로 Singleton과 Prototype의 차이를 알아보자</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">scopeTestClass</span> <span style="color:#f92672">{</span>
    <span style="color:#a6e22e">@Autowired</span>
    AnnotationBeanTest anno1<span style="color:#f92672">;</span>
    <span style="color:#a6e22e">@Autowired</span>
    AnnotationBeanTest anno2<span style="color:#f92672">;</span>
    
    <span style="color:#a6e22e">@Test</span>
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">beanTest</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;first bean : &#34;</span><span style="color:#f92672">+</span>anno1<span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;second bean : &#34;</span><span style="color:#f92672">+</span>anno2<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><figure>
    <img src="https://drive.google.com/uc?export=view&amp;id=1x-1-B00LCp-cBwOTrdKQae4jJvrV8cwv"
         alt="singleton"/> <figcaption>
            <p>singleton</p>
        </figcaption>
</figure>

<figure>
    <img src="https://drive.google.com/uc?export=view&amp;id=1z6qCXtUZxgoXX7YxU1O4BCs9OD38wCHr"
         alt="protoType"/> <figcaption>
            <p>protoType</p>
        </figcaption>
</figure>

<p>이렇게 오브젝트에 할당된 값이 바뀐걸 알 수 있다.</p>
<h2 id="bean-life-cycle-callback">Bean Life Cycle Callback</h2>
<p>기본적으로 빈의 라이프사이클은 컨테이너가 관리해주지만 스프링에서는 이를 개발자가 콜백함수를 통해 관여 할 수 있다. 콜백함수는 인터페이스로 이루어져 있어 이를 구현해주면 빈의 라이프 사이클 주기에서 내가 원하는 작용을 실행 시킬 수 있다.
그럼 스프링에서 기본적으로 제공하는 라이프사이클의 콜백 방법들을 알아보자</p>
<h3 id="1-생성단계">1. 생성단계</h3>
<p>먼저 생성단계에서 관여하는 콜백함수 지정방법은 3가지가 있다.</p>
<ol>
<li>@PostConstruct</li>
<li>InitializingBean 구현</li>
<li>@Bean(initMethod = &ldquo;init&rdquo;) 지정 (XML로도 지정가능)</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> co.kr.jparangdev.spring_test1.model<span style="color:#f92672">;</span>

<span style="color:#f92672">import</span> org.springframework.beans.factory.InitializingBean<span style="color:#f92672">;</span>

<span style="color:#f92672">import</span> javax.annotation.PostConstruct<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AnnotationBeanTest</span> <span style="color:#66d9ef">implements</span> InitializingBean <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> String name<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> value<span style="color:#f92672">;</span>

    <span style="color:#a6e22e">@PostConstruct</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">postContract</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Post Contract!&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">afterPropertiesSet</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;InitializingBean&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> name<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getValue</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> value<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setValue</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Configuration</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestConfig</span> <span style="color:#f92672">{</span>
    <span style="color:#a6e22e">@Bean</span><span style="color:#f92672">(</span>initMethod <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;init&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#66d9ef">public</span> AnnotationBeanTest <span style="color:#a6e22e">annotationBeanTest</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> AnnotationBeanTest<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><figure>
    <img src="https://drive.google.com/uc?export=view&amp;id=1ZmNfukGenyghVL4knuX5Zh0AUeBEpwuw"
         alt="protoType"/> <figcaption>
            <p>메소드가 적용되는 순서도 알 수 있다.</p>
        </figcaption>
</figure>

<p>XML로는 이렇게 지정 할 수 있다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#f92672">&lt;bean</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;xmlBeanTest&#34;</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;co.kr.jparangdev.spring_test1.model.XmlBeanTest&#34;</span> <span style="color:#a6e22e">init-method=</span><span style="color:#e6db74">&#34;init&#34;</span><span style="color:#f92672">/&gt;</span>
</code></pre></div><h3 id="2-소멸단계">2. 소멸단계</h3>
<p>소멸단계도 생성단계와 같이 3가지 방법을 제공한다.</p>
<ol>
<li>@PreDestroy</li>
<li>DisposableBean 구현</li>
<li>@Bean(destroyMethod=&ldquo;distroy&rdquo;) 지정 (XML로도 지정가능)</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> co.kr.jparangdev.spring_test1.model<span style="color:#f92672">;</span>

<span style="color:#f92672">import</span> org.springframework.beans.factory.DisposableBean<span style="color:#f92672">;</span>
<span style="color:#f92672">import</span> javax.annotation.PreDestroy<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AnnotationBeanTest</span> <span style="color:#66d9ef">implements</span>  DisposableBean <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> String name<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> value<span style="color:#f92672">;</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">destroy</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;DisposableBean !!&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">distroy</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;distroy !!&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@PreDestroy</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PreDestroy</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;PreDestroy !!&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> name<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getValue</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> value<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setValue</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> co.kr.jparangdev.spring_test1.config<span style="color:#f92672">;</span>

<span style="color:#f92672">import</span> co.kr.jparangdev.spring_test1.model.AnnotationBeanTest<span style="color:#f92672">;</span>
<span style="color:#f92672">import</span> org.springframework.context.annotation.Bean<span style="color:#f92672">;</span>
<span style="color:#f92672">import</span> org.springframework.context.annotation.Configuration<span style="color:#f92672">;</span>

<span style="color:#a6e22e">@Configuration</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestConfig</span> <span style="color:#f92672">{</span>
    <span style="color:#a6e22e">@Bean</span><span style="color:#f92672">(</span>destroyMethod<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;distroy&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#66d9ef">public</span> AnnotationBeanTest <span style="color:#a6e22e">annotationBeanTest</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> AnnotationBeanTest<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>빈 소멸과 동시에 프린트가 시작된다.
<figure>
    <img src="https://drive.google.com/uc?export=view&amp;id=1_hDpZGBwfcqOscKZg_cw4NGOa7IWgszq"
         alt="distroy bean"/> 
</figure>
</p>
<h3 id="결론">결론</h3>
<p>SpringFramwork를 이해하기 위해선 Bean자체의 이해도 필수적이라 생각된다. 스프링 컨테이너는 기동시 필요한 모든 싱글톤빈을 로드 한 후 지연없이 사용가능하도록 알아서해준다.<br>
이로인해 개발자는 비즈니스로직에 좀더 집중이 가능하도록 해준다. 스프링에는 여러가지 장점이 있으나 이러한 내가 사용하고자 하는 객체를 관리해주는 기능도도 굉장히 유용하다 생각된다.</p>
]]></content>
        </item>
        
        <item>
            <title>github.io 블로그 만들기 - 2</title>
            <link>/posts/blog/hugo-2/</link>
            <pubDate>Tue, 22 Dec 2020 21:00:00 +0900</pubDate>
            
            <guid>/posts/blog/hugo-2/</guid>
            <description>이전 블로그에 이어 이번엔 테마를 설정해보도록 하겠다.
https://themes.gohugo.io/tags/blog/
위 페이지에 접속하여 원하는 테마를 골라보도록 하자. 일반적으로 모든 테마에서는 설치법과 기본적인 사용법이 개발자분들이 적어 놓은 경우가 많아 이를 참고하는것이 좋긴하다.
일단 내가 적용했던 방법을 기록해본다.
간편하게 생성했던 프로젝트 파일 themes 아래 서브모듈로 추가하거나 (테마제작자의 업데이트가 상관없는경우 가능)
$ git clone &amp;lt;테마 Git주소&amp;gt; themes/&amp;lt;테마이름&amp;gt; $ git submodule add &amp;lt;테마 Git주소&amp;gt; themes/&amp;lt;테마이름&amp;gt; 아니면 직접 다운받아 themes폴더 아래에 위치시켜주면 된다.
이후 config.toml파일을 각 테마에 맞게 수정해줘야한다.</description>
            <content type="html"><![CDATA[<p>이전 블로그에 이어 이번엔 테마를 설정해보도록 하겠다.</p>
<p><a href="https://themes.gohugo.io/tags/blog/">https://themes.gohugo.io/tags/blog/</a></p>
<p>위 페이지에 접속하여 원하는 테마를 골라보도록 하자. 
일반적으로 모든 테마에서는 설치법과 기본적인 사용법이 개발자분들이 적어 놓은 경우가 많아 이를 참고하는것이 좋긴하다.</p>
<p>일단 내가 적용했던 방법을 기록해본다.</p>
<p>간편하게 생성했던 프로젝트 파일 themes 아래 서브모듈로 추가하거나 (테마제작자의 업데이트가 상관없는경우 가능)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ git clone &lt;테마 Git주소&gt; themes/&lt;테마이름&gt;
$ git submodule add &lt;테마 Git주소&gt; themes/&lt;테마이름&gt;
</code></pre></div><p>아니면 직접 다운받아 themes폴더 아래에 위치시켜주면 된다.</p>
<p>이후 config.toml파일을 각 테마에 맞게 수정해줘야한다. 
테마별 사이트에 자세히 나와있어 맞게 수정하면 되며, 기본적으로 baseURL, Theme, Title 정도는 기본으로 설정해야 한다.</p>
<p>이제 시험삼아 Post를 하나 생성해보도록 하자</p>
<p>Hugo는 Content 아래의 폴더가 게시글이 되도록 기본적으로 설정되어 있다. 
나는 주제에 맞춰 혹은 시리즈에 맞춰 폴더를 생성하고 그아래 .md 파일을 하나 생성해서 글을 작성했다.</p>
<p>테마도 적용되었는지 확인하고 글도 잘올라갔는지 확인하려면 먼저 내컴퓨터에서 홈페이지를 기동해봐야한다. 
Intellij같은 툴을 쓰는경우 환경 설정을 통해 쉽게 본인 PC에 서버를 올릴 수 있고 shell을 통해 기동도 가능하다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ hugo server -D
</code></pre></div><figure>
    <img src="/images/hugo/hugo-4.png"
         alt="hugo server"/> <figcaption>
            <p>해당화면처럼 빌드가 되면 가능</p>
        </figcaption>
</figure>

<p>이제 localhost:1313번에 접속해서 자신의 블로그를 확인해보도록 하자</p>
]]></content>
        </item>
        
        <item>
            <title>github.io 블로그 만들기 - 1</title>
            <link>/posts/blog/hugo-1/</link>
            <pubDate>Thu, 17 Dec 2020 20:45:00 +0900</pubDate>
            
            <guid>/posts/blog/hugo-1/</guid>
            <description>기록은 힘이다 말이 있듯이 자신만의 지식 아카이브를 만들어 두는 것은 큰 도움이 된다. 다른사람에게 정보 전달의 목적도 있지만 나 자신의 생각을 정리하기 위해 블로그를 기록하기로 한다.
github는 간편하면서 무료로 호스팅을 한다. 다만, 정적인 페이지로만 생성이 가능
내가 만들 블로그의 경우는 방문자에게 정보 전달만이 목적이기에 Static Website로 구성 현재는 많은 개발자분들이 Github를 통해 블로그를 구축하는듯 하다
먼저 블로그를 구축하기전에 Git에 대한 기본적이 지식이 필요하다. Git에 대한 정보는 이미 웹에 많은 좋은 기록이 많기 때문에 따로 다루진 않는다.</description>
            <content type="html"><![CDATA[<p>기록은 힘이다 말이 있듯이 자신만의 지식 아카이브를 만들어 두는 것은 큰 도움이 된다.
다른사람에게 정보 전달의 목적도 있지만 나 자신의 생각을 정리하기 위해 블로그를 기록하기로 한다.</p>
<p>github는 간편하면서 무료로 호스팅을 한다. 다만, 정적인 페이지로만 생성이 가능</p>
<p>내가 만들 블로그의 경우는 방문자에게 정보 전달만이 목적이기에 Static Website로 구성
현재는 많은 개발자분들이 Github를 통해 블로그를 구축하는듯 하다</p>
<p>먼저 블로그를 구축하기전에 Git에 대한 기본적이 지식이 필요하다.
Git에 대한 정보는 이미 웹에 많은 좋은 기록이 많기 때문에 따로 다루진 않는다.
대신 Opentutorials의 강의를 링크한다.<br>
<a href="https://opentutorials.org/course/2708">https://opentutorials.org/course/2708</a></p>
<p>나는 Hugo를 사용하여 블로그를 구성하기로 했다. 
Github.io에 Jekyll가 대표적이지만,
Jekyll에 비해 빌드속도가 빠르다는 점과 Go 언어를 사용한다는점이 매력적이라 생각해서 Hugo를 선택!</p>
<p>비록 Jekyll에 비해 메뉴얼도 템플릿도 부족한 듯 싶으나 일단 Hugo를 사용하기로 맘먹고 시작해보았다.
Hugo에 마음에 드는 테마가 있던 것도 한 몫했다.</p>
<p>먼저 Hugo는 <a href="https://gohugo.io/getting-started/installing/">https://gohugo.io/getting-started/installing/</a> 에서 OS별 설치 방법을 알 수 있고 
Git (<a href="https://github.com/gohugoio/hugo">https://github.com/gohugoio/hugo</a>) 에서 최신 Hugo를 다운받아 사용이 가능하다. OS는 Window 10에서 진행하였다.</p>
<p>Hugo를 다운받았다면 원하는 위치에서 압축을 풀고 bin폴더 안의 hugo.exe의 환경변수를 설정해주도록 한다.
<figure>
    <img src="/images/hugo/hugo-1.png"
         alt="hugo setting path"/> <figcaption>
            <p>윈도우의 시스템 환경설정</p>
        </figcaption>
</figure>
</p>
<p>이후 cmd를 통해 Hugo가 제대로 작동하는 지 확인한다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">    $ hugo version
</code></pre></div><p>다음과 같은 화면이 나온다면 정상적으로 작동 된 것
<figure>
    <img src="/images/hugo/hugo-2.png"
         alt="hugo install"/> <figcaption>
            <p>Hugo 버전확인</p>
        </figcaption>
</figure>
</p>
<p>이제 블로그용 소스를 만들 위치에 hugo site파일을 만들어보도록 하자</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">    $ hugo new site C:<span style="color:#ae81ff">\j</span>aprangev<span style="color:#ae81ff">\t</span>estsite
</code></pre></div><p>해당 메세지가 출력되고 파일이 잘 생성된 것을 확인하였으면 기본적인 블로그 사이트 소스 생성이 된 것이다.</p>
<figure>
    <img src="/images/hugo/hugo-3.png"
         alt="hugo complete"/> <figcaption>
            <p>간략하게 테마적용법과 구동방법이 나온다</p>
        </figcaption>
</figure>

<p>다음으로 Git을 통해 형상관리가 가능하도록 원격 git을 연결하도록 하자
먼저 <a href="https://github.com">https://github.com</a> 으로 접속하여 저장소를 2개 생성해야한다.</p>
<ol>
<li>블로그 소스용 저장소</li>
<li>블로그가 게시될 Github.io 용 저장소</li>
</ol>
<p>new site로 생성한 블로그 소스를 원격 저장소에 연결해보자.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">    $ cd C:<span style="color:#ae81ff">\j</span>aprangev<span style="color:#ae81ff">\t</span>estsite
    $ git init
    $ git add .
    $ git commit -m <span style="color:#e6db74">&#34;first commit&#34;</span>
    $ git branch -M main
    $ git remote add origin https://github.com/jparangdev/testsite-src.git
    $ git push -u origin main
</code></pre></div><p>github에 접속해 해당 소스가 제대로 푸쉬가 되었는지 확인</p>
<p>여기까지 글을 마치고 다음에 테마를 연결해보자~~~~</p>
]]></content>
        </item>
        
    </channel>
</rss>
