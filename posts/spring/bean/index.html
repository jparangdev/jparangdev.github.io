<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>콩(Bean) 이야기 | Jparangdev'Blog</title><meta name=keywords content="spring-framework,spring-boot,java"><meta name=description content="Spring Bean"><meta name=author content="jparangdev"><link rel=canonical href=https://japarangdev.gitio.com/posts/spring/bean/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.bc435bed1061be2618667408894ae8a5d27c970831ce57f287e42f911918fcbc.css integrity="sha256-vENb7RBhviYYZnQIiUropdJ8lwgxzlfyh+QvkRkY/Lw=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://japarangdev.gitio.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://japarangdev.gitio.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://japarangdev.gitio.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://japarangdev.gitio.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://japarangdev.gitio.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.82.1"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="콩(Bean) 이야기"><meta property="og:description" content="Spring Bean"><meta property="og:type" content="article"><meta property="og:url" content="https://japarangdev.gitio.com/posts/spring/bean/"><meta property="og:image" content="https://japarangdev.gitio.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-02T21:23:00+09:00"><meta property="article:modified_time" content="2021-01-02T21:23:00+09:00"><meta property="og:site_name" content="Jparangdev's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://japarangdev.gitio.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="콩(Bean) 이야기"><meta name=twitter:description content="Spring Bean"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://japarangdev.gitio.com/posts/"},{"@type":"ListItem","position":2,"name":"콩(Bean) 이야기","item":"https://japarangdev.gitio.com/posts/spring/bean/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"콩(Bean) 이야기","name":"콩(Bean) 이야기","description":"Spring Bean","keywords":["spring-framework","spring-boot","java"],"articleBody":"\r이 콩 이야기는 아니다\n\r\rBean이 뭔데? 간단히 말하면 스프링프레임워크에서 사용하는 자바의 객체를 Bean이라 할 수 있다.\nSpring IoC Container(컨테이너)에서 관리되기 때문에 자바객체와 다르게 Bean(빈)이라 말한다.\nXml이나 어노테이션을 이용해 메타데이터를 설정하면 컨테이너는 이를 확인해서 빈을 생성하고 해당 빈의 라이프 사이클을 관리하며 필요한 부분에 주입하여 의존성을 관리한다.\n\r이 콩도 아니다 이 콩도 아니다\n\r\r그럼 왜 굳이 Bean을 사용하는가?\n스프링에서 개발자는 의존성 주입과 객채의 생성과 소멸은 컨테이너가 해줄테니 개발에 집중할 수 해주는 것이 목적이다.\n\r그럼 빈을 생성하는 예시를 보며 실제로 빈이 스프링상에서 어떻게 작용하는지 알아보자 (Spring Boot)\n빈을 만드는 방법은 여러가지가 있지만 대표적으로 쓰이는 방법을 예시들어 본다.\n빈 생성방법 소스상에서 자바 오브젝트를 생성한 뒤 각 방법으로 등록을 할 수 있다.\n  XML로 지정\napplication.xml에 빈을 등록하거나 resource 폴더아래 XML파일을 생성 후 지정한다.\n  xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"  id=\"xmlBeanTest\" class=\"co.kr.jparangdev.spring_test1.model.XmlBeanTest\" /  여러 XML을 만든 경우 설정에서 BeanFactory에서 직접 Context를 불러와 Bean을 넣어주거나, application.xml파일에 Import해서 사용하는 방법이 있다. 빈을 일일히 다 표기해야하며 Context관리가 어려워 불편한 점이 조금 있어보인다.\n  Component-Scan + Annotation\napplication.xml 에서 Annotation으로 마킹된 객체를 빈으로 주입하는 방법이 있다.\n base-package=\"co.kr.jparangdev.spring_test1\"/ 이후 base-package 아래 지정된 객체중 @Component, @Service, @Controller, @Repository으로 마킹한 객체는 빈에 등록된다.\npackage co.kr.jparangdev.spring_test1.controller; import org.springframework.stereotype.Controller; @Controller public class BeanTestController { }   @Configuration + @Bean\nSpring boot의 경우 @Configuration을 지정한 객체 안에 @Bean으로 생성된 메소드를 생성해서 리턴해주면 빈을 주입 할 수 있다.\npackage co.kr.jparangdev.spring_test1.config; import co.kr.jparangdev.spring_test1.model.AnnotationBeanTest; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class TestConfig { @Bean public AnnotationBeanTest annotationBeanTest() { return new AnnotationBeanTest(); } }   이제 이렇게 주입한 빈들이 제대로 들어갔는지 확인해보자\n@SpringBootApplication public class SpringTest1Application { public static void main(String[] args) { SpringApplication.run(SpringTest1Application.class, args); } @Bean // Annotation으로 등록한 bean 확인  public CommandLineRunner outBeanName(ApplicationContext ctx) { return args - { System.out.println(\"============= Bean Start =============\"); String[] beanNames = ctx.getBeanDefinitionNames(); Arrays.stream(beanNames).forEach( System.out::println ); System.out.println(\"============= Bean End =============\"); }; } @Bean // xml로 등록한 bean 확인  public CommandLineRunner outXmlBeanName() { return args - { System.out.println(\"============= XmlBean Start =============\"); ApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\"); String[] beanNames = ctx.getBeanDefinitionNames(); Arrays.stream(beanNames).forEach( System.out::println ); System.out.println(\"============= XmlBean End =============\"); }; } } 결과 화면으로 등록된 Bean의 Name들을 확인 할 수 있다. \rTest메소드도 Bean으로 등록되었다.\n\r\r이런 식으로 컨테이너에 등록된 빈들을 여러 방법으로 의존관계를 가지며 상호작용이 가능하다. 그럼 의존관계는 어떻게 설정 할 수 있을까?\n의존관계를 표기하는 방식은 여러가지가 있지만 대표적인 @Autowired 이용한 주입 표기 법이 있다.\n@Service public class AutowiredTestService { @Autowired AnnotationBeanTest annotationBeanTest; } 다른 주입방법과 빈생성시 DI의 원리에 대해선 좀더 뒤에 알아 보도록 하겠다.\n또한 컨테이너에선 빈의 Scope를 관리하기도 한다.\n\r여기서 web spring에서 사용하는 것은 제외하고 singleton과 prototype만 좀더 자세히 알아보자\nSingleton Scope스프링 컨테이너는 빈에 관하여 하나의 인스턴스만 관리하며 빈에 대한 요청에 하나의 인스턴스만 반환하게 된다. 컨테이너는 빈을 생성하며 캐시에 저장하여 해당 빈을 참조하는 경우 캐시된 인스턴스를 반환한다. 우리가 알고 있는 Singleton Disign Pattern 과는 조금 다르게 작용한다고 한다. 일반적인 싱글톤 패턴은 하나의 시스템 내부에서 하나의 클래스에 하나의 인스턴스만 존재하지만 빈의 싱글톤은 컨테이너내의 하나의 빈의 정의에 대해 하나의 인스턴스를 가지는 걸 말한다. \r출처 : https://docs.spring.io/spring-framework/docs/5.3.5-SNAPSHOT/reference/html/core.html#beans-factory-scopes-singleton\n\r\rPrototype Scope프로토 타입은 싱글톤 패턴과 반대로 컨테이너는 모든 빈의 요청에 하나하나의 인스턴스를 만들어 준다. 일반적으로 상태값을 사용해야 하는 빈은 프로토타입을 사용하고 상태를 고려 안하는 경우는 싱글톤을 사용한다. \r출처 : https://docs.spring.io/spring-framework/docs/5.3.5-SNAPSHOT/reference/html/core.html#beans-factory-scopes-singleton\n\r\r빈의 Scope를 지정하는 방법은 빈의 생성방법과 맞물려 있다.\n xml에 Scope속성을 추가해준다.   id=\"xmlBeanTest\" class=\"co.kr.jparangdev.spring_test1.model.XmlBeanTest\" scope=\"singleton\"/ @Scope를 이용한다.  @Configuration public class TestConfig { @Bean @Scope(\"protoType\") public AnnotationBeanTest annotationBeanTest() { return new AnnotationBeanTest(); } } 그럼 실제로 Singleton과 Prototype의 차이를 알아보자\npublic class scopeTestClass { @Autowired AnnotationBeanTest anno1; @Autowired AnnotationBeanTest anno2; @Test void beanTest() { System.out.println(\"first bean : \"+anno1); System.out.println(\"second bean : \"+anno2); } } \rsingleton\n\r\r\rprotoType\n\r\r이렇게 오브젝트에 할당된 값이 바뀐걸 알 수 있다.\nBean Life Cycle Callback 기본적으로 빈의 라이프사이클은 컨테이너가 관리해주지만 스프링에서는 이를 개발자가 콜백함수를 통해 관여 할 수 있다. 콜백함수는 인터페이스로 이루어져 있어 이를 구현해주면 빈의 라이프 사이클 주기에서 내가 원하는 작용을 실행 시킬 수 있다. 그럼 스프링에서 기본적으로 제공하는 라이프사이클의 콜백 방법들을 알아보자\n1. 생성단계 먼저 생성단계에서 관여하는 콜백함수 지정방법은 3가지가 있다.\n @PostConstruct InitializingBean 구현 @Bean(initMethod = “init”) 지정 (XML로도 지정가능)  package co.kr.jparangdev.spring_test1.model; import org.springframework.beans.factory.InitializingBean; import javax.annotation.PostConstruct; public class AnnotationBeanTest implements InitializingBean { private String name; private int value; @PostConstruct public void postContract() { System.out.println(\"Post Contract!\"); } @Override public void afterPropertiesSet() throws Exception { System.out.println(\"InitializingBean\"); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } } @Configuration public class TestConfig { @Bean(initMethod = \"init\") public AnnotationBeanTest annotationBeanTest() { return new AnnotationBeanTest(); } } \r메소드가 적용되는 순서도 알 수 있다.\n\r\rXML로는 이렇게 지정 할 수 있다.\n id=\"xmlBeanTest\" class=\"co.kr.jparangdev.spring_test1.model.XmlBeanTest\" init-method=\"init\"/ 2. 소멸단계 소멸단계도 생성단계와 같이 3가지 방법을 제공한다.\n @PreDestroy DisposableBean 구현 @Bean(destroyMethod=“distroy”) 지정 (XML로도 지정가능)  package co.kr.jparangdev.spring_test1.model; import org.springframework.beans.factory.DisposableBean; import javax.annotation.PreDestroy; public class AnnotationBeanTest implements DisposableBean { private String name; private int value; @Override public void destroy() throws Exception { System.out.println(\"DisposableBean !!\"); } public void distroy() { System.out.println(\"distroy !!\"); } @PreDestroy public void PreDestroy() { System.out.println(\"PreDestroy !!\"); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } } package co.kr.jparangdev.spring_test1.config; import co.kr.jparangdev.spring_test1.model.AnnotationBeanTest; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class TestConfig { @Bean(destroyMethod=\"distroy\") public AnnotationBeanTest annotationBeanTest() { return new AnnotationBeanTest(); } } 빈 소멸과 동시에 프린트가 시작된다. \r결론 SpringFramwork를 이해하기 위해선 Bean자체의 이해도 필수적이라 생각된다. 스프링 컨테이너는 기동시 필요한 모든 싱글톤빈을 로드 한 후 지연없이 사용가능하도록 알아서해준다.\n이로인해 개발자는 비즈니스로직에 좀더 집중이 가능하도록 해준다. 스프링에는 여러가지 장점이 있으나 이러한 내가 사용하고자 하는 객체를 관리해주는 기능도도 굉장히 유용하다 생각된다.\n","wordCount":"895","inLanguage":"en","datePublished":"2021-01-02T21:23:00+09:00","dateModified":"2021-01-02T21:23:00+09:00","author":{"@type":"Person","name":"jparangdev"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://japarangdev.gitio.com/posts/spring/bean/"},"publisher":{"@type":"Organization","name":"Jparangdev'Blog","logo":{"@type":"ImageObject","url":"https://japarangdev.gitio.com/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://japarangdev.gitio.com/ accesskey=h title="Jparangdev :) (Alt + H)">Jparangdev :)</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://japarangdev.gitio.com/archives/ title=Post><span>Post</span></a></li><li><a href=https://japarangdev.gitio.com/categories/ title=categories><span>categories</span></a></li><li><a href=https://japarangdev.gitio.com/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://japarangdev.gitio.com/>Home</a>&nbsp;»&nbsp;<a href=https://japarangdev.gitio.com/posts/>Posts</a></div><h1 class=post-title>콩(Bean) 이야기</h1><div class=post-description>Spring Bean</div><div class=post-meta>January 2, 2021&nbsp;·&nbsp;5 min&nbsp;·&nbsp;jparangdev</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#bean%ec%9d%b4-%eb%ad%94%eb%8d%b0 aria-label="Bean이 뭔데?">Bean이 뭔데?</a></li><li><a href=#%eb%b9%88-%ec%83%9d%ec%84%b1%eb%b0%a9%eb%b2%95 aria-label="빈 생성방법">빈 생성방법</a></li><li><a href=#bean-life-cycle-callback aria-label="Bean Life Cycle Callback">Bean Life Cycle Callback</a><ul><li><a href=#1-%ec%83%9d%ec%84%b1%eb%8b%a8%ea%b3%84 aria-label="1. 생성단계">1. 생성단계</a></li><li><a href=#2-%ec%86%8c%eb%a9%b8%eb%8b%a8%ea%b3%84 aria-label="2. 소멸단계">2. 소멸단계</a></li><li><a href=#%ea%b2%b0%eb%a1%a0 aria-label=결론>결론</a></li></ul></li></ul></div></details></div><div class=post-content><figure class=align-center><img loading=lazy src="https://drive.google.com/uc?export=view&id=10PKsiqX5O0rXqSFMLokk-W5TkX3r_Lke#center" alt=spring><figcaption><p>이 콩 이야기는 아니다</p></figcaption></figure><h2 id=bean이-뭔데>Bean이 뭔데?<a hidden class=anchor aria-hidden=true href=#bean이-뭔데>#</a></h2><p>간단히 말하면 스프링프레임워크에서 사용하는 자바의 객체를 Bean이라 할 수 있다.<br>Spring IoC Container(컨테이너)에서 관리되기 때문에 자바객체와 다르게 Bean(빈)이라 말한다.<br>Xml이나 어노테이션을 이용해 메타데이터를 설정하면 컨테이너는 이를 확인해서 빈을 생성하고 해당 빈의 라이프 사이클을 관리하며 필요한 부분에 주입하여 의존성을 관리한다.</p><figure class=align-center><img loading=lazy src="https://drive.google.com/uc?export=view&id=1A9aOfWAN-6M0nBpsBJQThfWMylVVckTX#center" alt=spring><figcaption><p>이 콩도 아니다 이 콩도 아니다</p></figcaption></figure><p>그럼 왜 굳이 Bean을 사용하는가?<br>스프링에서 개발자는 의존성 주입과 객채의 생성과 소멸은 컨테이너가 해줄테니 개발에 집중할 수 해주는 것이 목적이다.</p><figure class=align-center><img loading=lazy src="https://drive.google.com/uc?export=view&id=1QxKmTIKypqEqZWO7tiy1Y0gq764by_3z#center" alt=spring></figure><p>그럼 빈을 생성하는 예시를 보며 실제로 빈이 스프링상에서 어떻게 작용하는지 알아보자 (Spring Boot)<br>빈을 만드는 방법은 여러가지가 있지만 대표적으로 쓰이는 방법을 예시들어 본다.</p><h2 id=빈-생성방법>빈 생성방법<a hidden class=anchor aria-hidden=true href=#빈-생성방법>#</a></h2><p>소스상에서 자바 오브젝트를 생성한 뒤 각 방법으로 등록을 할 수 있다.</p><ol><li><p><strong>XML로 지정</strong><br>application.xml에 빈을 등록하거나 resource 폴더아래 XML파일을 생성 후 지정한다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=color:#75715e>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span style=color:#f92672>&lt;beans</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#34;http://www.springframework.org/schema/beans&#34;</span>
       <span style=color:#a6e22e>xmlns:xsi=</span><span style=color:#e6db74>&#34;http://www.w3.org/2001/XMLSchema-instance&#34;</span>
       <span style=color:#a6e22e>xsi:schemaLocation=</span><span style=color:#e6db74>&#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&#34;</span><span style=color:#f92672>&gt;</span>
   
    <span style=color:#f92672>&lt;bean</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;xmlBeanTest&#34;</span> <span style=color:#a6e22e>class=</span><span style=color:#e6db74>&#34;co.kr.jparangdev.spring_test1.model.XmlBeanTest&#34;</span> <span style=color:#f92672>/&gt;</span>
<span style=color:#f92672>&lt;/beans&gt;</span>
</code></pre></div><p>여러 XML을 만든 경우 설정에서 BeanFactory에서 직접 Context를 불러와 Bean을 넣어주거나, application.xml파일에 Import해서 사용하는 방법이 있다.
빈을 일일히 다 표기해야하며 Context관리가 어려워 불편한 점이 조금 있어보인다.</p></li><li><p><strong>Component-Scan + Annotation</strong><br>application.xml 에서 Annotation으로 마킹된 객체를 빈으로 주입하는 방법이 있다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=color:#f92672>&lt;context:component-scan</span> <span style=color:#a6e22e>base-package=</span><span style=color:#e6db74>&#34;co.kr.jparangdev.spring_test1&#34;</span><span style=color:#f92672>/&gt;</span>
</code></pre></div><p>이후 base-package 아래 지정된 객체중 @Component, @Service, @Controller, @Repository으로 마킹한 객체는 빈에 등록된다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>package</span> co.kr.jparangdev.spring_test1.controller<span style=color:#f92672>;</span>
   
<span style=color:#f92672>import</span> org.springframework.stereotype.Controller<span style=color:#f92672>;</span>
   
<span style=color:#a6e22e>@Controller</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BeanTestController</span> <span style=color:#f92672>{</span>
<span style=color:#f92672>}</span>
</code></pre></div></li><li><p><strong>@Configuration + @Bean</strong><br>Spring boot의 경우 @Configuration을 지정한 객체 안에 @Bean으로 생성된 메소드를 생성해서 리턴해주면 빈을 주입 할 수 있다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#f92672>package</span> co.kr.jparangdev.spring_test1.config<span style=color:#f92672>;</span>
       
    <span style=color:#f92672>import</span> co.kr.jparangdev.spring_test1.model.AnnotationBeanTest<span style=color:#f92672>;</span>
    <span style=color:#f92672>import</span> org.springframework.context.annotation.Bean<span style=color:#f92672>;</span>
    <span style=color:#f92672>import</span> org.springframework.context.annotation.Configuration<span style=color:#f92672>;</span>
       
    <span style=color:#a6e22e>@Configuration</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestConfig</span> <span style=color:#f92672>{</span>
        <span style=color:#a6e22e>@Bean</span>
        <span style=color:#66d9ef>public</span> AnnotationBeanTest <span style=color:#a6e22e>annotationBeanTest</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> AnnotationBeanTest<span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>
</code></pre></div></li></ol><p>이제 이렇게 주입한 빈들이 제대로 들어갔는지 확인해보자</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@SpringBootApplication</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SpringTest1Application</span> <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        SpringApplication<span style=color:#f92672>.</span><span style=color:#a6e22e>run</span><span style=color:#f92672>(</span>SpringTest1Application<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> args<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>


    <span style=color:#a6e22e>@Bean</span> <span style=color:#75715e>// Annotation으로 등록한 bean 확인
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> CommandLineRunner <span style=color:#a6e22e>outBeanName</span><span style=color:#f92672>(</span>ApplicationContext ctx<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> args <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;============= Bean Start =============&#34;</span><span style=color:#f92672>);</span>
            String<span style=color:#f92672>[]</span> beanNames <span style=color:#f92672>=</span> ctx<span style=color:#f92672>.</span><span style=color:#a6e22e>getBeanDefinitionNames</span><span style=color:#f92672>();</span>
            Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>stream</span><span style=color:#f92672>(</span>beanNames<span style=color:#f92672>).</span><span style=color:#a6e22e>forEach</span><span style=color:#f92672>(</span>
                    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>::</span>println
            <span style=color:#f92672>);</span>
            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;============= Bean End   =============&#34;</span><span style=color:#f92672>);</span>
        <span style=color:#f92672>};</span>
    <span style=color:#f92672>}</span>

    <span style=color:#a6e22e>@Bean</span> <span style=color:#75715e>// xml로 등록한 bean 확인
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> CommandLineRunner <span style=color:#a6e22e>outXmlBeanName</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> args <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;============= XmlBean Start =============&#34;</span><span style=color:#f92672>);</span>
            ApplicationContext ctx <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ClassPathXmlApplicationContext<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;beans.xml&#34;</span><span style=color:#f92672>);</span>
            String<span style=color:#f92672>[]</span> beanNames <span style=color:#f92672>=</span> ctx<span style=color:#f92672>.</span><span style=color:#a6e22e>getBeanDefinitionNames</span><span style=color:#f92672>();</span>
            Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>stream</span><span style=color:#f92672>(</span>beanNames<span style=color:#f92672>).</span><span style=color:#a6e22e>forEach</span><span style=color:#f92672>(</span>
                    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>::</span>println
            <span style=color:#f92672>);</span>
            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;============= XmlBean End   =============&#34;</span><span style=color:#f92672>);</span>
        <span style=color:#f92672>};</span>
    <span style=color:#f92672>}</span>

<span style=color:#f92672>}</span>
</code></pre></div><p>결과 화면으로 등록된 Bean의 Name들을 확인 할 수 있다.<figure class=align-center><img loading=lazy src="https://drive.google.com/uc?export=view&id=1Axx6JbPZgFPwBSomfmtIjsQbOclslu0u#center" alt=spring><figcaption><p>Test메소드도 Bean으로 등록되었다.</p></figcaption></figure></p><p>이런 식으로 컨테이너에 등록된 빈들을 여러 방법으로 의존관계를 가지며 상호작용이 가능하다.
그럼 의존관계는 어떻게 설정 할 수 있을까?</p><p>의존관계를 표기하는 방식은 여러가지가 있지만 대표적인 @Autowired 이용한 주입 표기 법이 있다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Service</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AutowiredTestService</span> <span style=color:#f92672>{</span>

    <span style=color:#a6e22e>@Autowired</span>
    AnnotationBeanTest annotationBeanTest<span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>다른 주입방법과 빈생성시 DI의 원리에 대해선 좀더 뒤에 알아 보도록 하겠다.<br>또한 컨테이너에선 빈의 Scope를 관리하기도 한다.</p><figure class=align-center><img loading=lazy src="https://drive.google.com/uc?export=view&id=1lmHcVtsQU4tcNPDwUwxCUg2BVTK8jFGH#center" alt="bean scope"></figure><p>여기서 web spring에서 사용하는 것은 제외하고 singleton과 prototype만 좀더 자세히 알아보자</p><p>Singleton Scope<br>스프링 컨테이너는 빈에 관하여 하나의 인스턴스만 관리하며 빈에 대한 요청에 하나의 인스턴스만 반환하게 된다. 컨테이너는 빈을 생성하며 캐시에 저장하여 해당 빈을 참조하는 경우 캐시된 인스턴스를 반환한다.
우리가 알고 있는 Singleton Disign Pattern 과는 조금 다르게 작용한다고 한다. 일반적인 싱글톤 패턴은 하나의 시스템 내부에서 하나의 클래스에 하나의 인스턴스만 존재하지만 빈의 싱글톤은 컨테이너내의 하나의 빈의 정의에 대해 하나의 인스턴스를 가지는 걸 말한다.<figure class=align-center><img loading=lazy src="https://drive.google.com/uc?export=view&id=1EiFDxsYs_RNOPlt3AzFuuKn8F_rf5_cf#center" alt=singleton><figcaption><p>출처 : <a href=https://docs.spring.io/spring-framework/docs/5.3.5-SNAPSHOT/reference/html/core.html#beans-factory-scopes-singleton>https://docs.spring.io/spring-framework/docs/5.3.5-SNAPSHOT/reference/html/core.html#beans-factory-scopes-singleton</a></p></figcaption></figure></p><p>Prototype Scope<br>프로토 타입은 싱글톤 패턴과 반대로 컨테이너는 모든 빈의 요청에 하나하나의 인스턴스를 만들어 준다. 일반적으로 상태값을 사용해야 하는 빈은 프로토타입을 사용하고 상태를 고려 안하는 경우는 싱글톤을 사용한다.<figure class=align-center><img loading=lazy src="https://drive.google.com/uc?export=view&id=1XUUTc_y2eKSc98nI19wa3W-xTxXfmiHN#center" alt=protoType><figcaption><p>출처 : <a href=https://docs.spring.io/spring-framework/docs/5.3.5-SNAPSHOT/reference/html/core.html#beans-factory-scopes-singleton>https://docs.spring.io/spring-framework/docs/5.3.5-SNAPSHOT/reference/html/core.html#beans-factory-scopes-singleton</a></p></figcaption></figure></p><p>빈의 Scope를 지정하는 방법은 빈의 생성방법과 맞물려 있다.</p><ol><li>xml에 Scope속성을 추가해준다.</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=color:#f92672>&lt;bean</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;xmlBeanTest&#34;</span> <span style=color:#a6e22e>class=</span><span style=color:#e6db74>&#34;co.kr.jparangdev.spring_test1.model.XmlBeanTest&#34;</span> <span style=color:#a6e22e>scope=</span><span style=color:#e6db74>&#34;singleton&#34;</span><span style=color:#f92672>/&gt;</span>
</code></pre></div><ol start=2><li>@Scope를 이용한다.</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Configuration</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestConfig</span> <span style=color:#f92672>{</span>
    <span style=color:#a6e22e>@Bean</span>
    <span style=color:#a6e22e>@Scope</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;protoType&#34;</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>public</span> AnnotationBeanTest <span style=color:#a6e22e>annotationBeanTest</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> AnnotationBeanTest<span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>그럼 실제로 Singleton과 Prototype의 차이를 알아보자</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>scopeTestClass</span> <span style=color:#f92672>{</span>
    <span style=color:#a6e22e>@Autowired</span>
    AnnotationBeanTest anno1<span style=color:#f92672>;</span>
    <span style=color:#a6e22e>@Autowired</span>
    AnnotationBeanTest anno2<span style=color:#f92672>;</span>
    
    <span style=color:#a6e22e>@Test</span>
    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>beanTest</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;first bean : &#34;</span><span style=color:#f92672>+</span>anno1<span style=color:#f92672>);</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;second bean : &#34;</span><span style=color:#f92672>+</span>anno2<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><figure class=align-center><img loading=lazy src="https://drive.google.com/uc?export=view&id=1x-1-B00LCp-cBwOTrdKQae4jJvrV8cwv#center" alt=singleton><figcaption><p>singleton</p></figcaption></figure><figure class=align-center><img loading=lazy src="https://drive.google.com/uc?export=view&id=1z6qCXtUZxgoXX7YxU1O4BCs9OD38wCHr#center" alt=protoType><figcaption><p>protoType</p></figcaption></figure><p>이렇게 오브젝트에 할당된 값이 바뀐걸 알 수 있다.</p><h2 id=bean-life-cycle-callback>Bean Life Cycle Callback<a hidden class=anchor aria-hidden=true href=#bean-life-cycle-callback>#</a></h2><p>기본적으로 빈의 라이프사이클은 컨테이너가 관리해주지만 스프링에서는 이를 개발자가 콜백함수를 통해 관여 할 수 있다. 콜백함수는 인터페이스로 이루어져 있어 이를 구현해주면 빈의 라이프 사이클 주기에서 내가 원하는 작용을 실행 시킬 수 있다.
그럼 스프링에서 기본적으로 제공하는 라이프사이클의 콜백 방법들을 알아보자</p><h3 id=1-생성단계>1. 생성단계<a hidden class=anchor aria-hidden=true href=#1-생성단계>#</a></h3><p>먼저 생성단계에서 관여하는 콜백함수 지정방법은 3가지가 있다.</p><ol><li>@PostConstruct</li><li>InitializingBean 구현</li><li>@Bean(initMethod = &ldquo;init&rdquo;) 지정 (XML로도 지정가능)</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>package</span> co.kr.jparangdev.spring_test1.model<span style=color:#f92672>;</span>

<span style=color:#f92672>import</span> org.springframework.beans.factory.InitializingBean<span style=color:#f92672>;</span>

<span style=color:#f92672>import</span> javax.annotation.PostConstruct<span style=color:#f92672>;</span>

<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AnnotationBeanTest</span> <span style=color:#66d9ef>implements</span> InitializingBean <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> String name<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> value<span style=color:#f92672>;</span>

    <span style=color:#a6e22e>@PostConstruct</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>postContract</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Post Contract!&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>afterPropertiesSet</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;InitializingBean&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> name<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setName</span><span style=color:#f92672>(</span>String name<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getValue</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> value<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setValue</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> value<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> value<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

<span style=color:#f92672>}</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Configuration</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestConfig</span> <span style=color:#f92672>{</span>
    <span style=color:#a6e22e>@Bean</span><span style=color:#f92672>(</span>initMethod <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;init&#34;</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>public</span> AnnotationBeanTest <span style=color:#a6e22e>annotationBeanTest</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> AnnotationBeanTest<span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><figure class=align-center><img loading=lazy src="https://drive.google.com/uc?export=view&id=1ZmNfukGenyghVL4knuX5Zh0AUeBEpwuw#center" alt=protoType><figcaption><p>메소드가 적용되는 순서도 알 수 있다.</p></figcaption></figure><p>XML로는 이렇게 지정 할 수 있다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=color:#f92672>&lt;bean</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;xmlBeanTest&#34;</span> <span style=color:#a6e22e>class=</span><span style=color:#e6db74>&#34;co.kr.jparangdev.spring_test1.model.XmlBeanTest&#34;</span> <span style=color:#a6e22e>init-method=</span><span style=color:#e6db74>&#34;init&#34;</span><span style=color:#f92672>/&gt;</span>
</code></pre></div><h3 id=2-소멸단계>2. 소멸단계<a hidden class=anchor aria-hidden=true href=#2-소멸단계>#</a></h3><p>소멸단계도 생성단계와 같이 3가지 방법을 제공한다.</p><ol><li>@PreDestroy</li><li>DisposableBean 구현</li><li>@Bean(destroyMethod=&ldquo;distroy&rdquo;) 지정 (XML로도 지정가능)</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>package</span> co.kr.jparangdev.spring_test1.model<span style=color:#f92672>;</span>

<span style=color:#f92672>import</span> org.springframework.beans.factory.DisposableBean<span style=color:#f92672>;</span>
<span style=color:#f92672>import</span> javax.annotation.PreDestroy<span style=color:#f92672>;</span>

<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AnnotationBeanTest</span> <span style=color:#66d9ef>implements</span>  DisposableBean <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> String name<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> value<span style=color:#f92672>;</span>

    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>destroy</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;DisposableBean !!&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>distroy</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;distroy !!&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#a6e22e>@PreDestroy</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>PreDestroy</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;PreDestroy !!&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> name<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setName</span><span style=color:#f92672>(</span>String name<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getValue</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> value<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setValue</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> value<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> value<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>package</span> co.kr.jparangdev.spring_test1.config<span style=color:#f92672>;</span>

<span style=color:#f92672>import</span> co.kr.jparangdev.spring_test1.model.AnnotationBeanTest<span style=color:#f92672>;</span>
<span style=color:#f92672>import</span> org.springframework.context.annotation.Bean<span style=color:#f92672>;</span>
<span style=color:#f92672>import</span> org.springframework.context.annotation.Configuration<span style=color:#f92672>;</span>

<span style=color:#a6e22e>@Configuration</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestConfig</span> <span style=color:#f92672>{</span>
    <span style=color:#a6e22e>@Bean</span><span style=color:#f92672>(</span>destroyMethod<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;distroy&#34;</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>public</span> AnnotationBeanTest <span style=color:#a6e22e>annotationBeanTest</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> AnnotationBeanTest<span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>빈 소멸과 동시에 프린트가 시작된다.<figure class=align-center><img loading=lazy src="https://drive.google.com/uc?export=view&id=1_hDpZGBwfcqOscKZg_cw4NGOa7IWgszq#center" alt="distroy bean"></figure></p><h3 id=결론>결론<a hidden class=anchor aria-hidden=true href=#결론>#</a></h3><p>SpringFramwork를 이해하기 위해선 Bean자체의 이해도 필수적이라 생각된다. 스프링 컨테이너는 기동시 필요한 모든 싱글톤빈을 로드 한 후 지연없이 사용가능하도록 알아서해준다.<br>이로인해 개발자는 비즈니스로직에 좀더 집중이 가능하도록 해준다. 스프링에는 여러가지 장점이 있으나 이러한 내가 사용하고자 하는 객체를 관리해주는 기능도도 굉장히 유용하다 생각된다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://japarangdev.gitio.com/tags/spring-framework/>spring-framework</a></li><li><a href=https://japarangdev.gitio.com/tags/spring-boot/>spring-boot</a></li><li><a href=https://japarangdev.gitio.com/tags/java/>java</a></li></ul><nav class=paginav><a class=prev href=https://japarangdev.gitio.com/posts/blog/hugo-2/><span class=title>« Prev Page</span><br><span>github.io 블로그 만들기 - 2</span></a>
<a class=next href=https://japarangdev.gitio.com/posts/kafka/about-kafka-1/><span class=title>Next Page »</span><br><span>Kafka 알아보기 - 1</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://japarangdev.gitio.com/>Jparangdev'Blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>